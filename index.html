<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>VR Cinema (Quest • Co-Watch • Reactive BG • Wrist UI Float/Attach)</title>

  <style>
    :root{
      --c1:#00f2ff;
      --c2:#7000ff;
      --panel:rgba(12,12,18,.90);
      --border:rgba(255,255,255,.12);
      --text:#fff;
      --muted:rgba(255,255,255,.72);
      --bg:#000;
    }
    html,body{margin:0;padding:0;width:100%;height:100%;overflow:hidden;background:var(--bg);color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    }
    #canvas-container{position:absolute;inset:0;z-index:1;}

    #ui-layer{
      position:absolute;left:50%;bottom:18px;transform:translateX(-50%);
      width:min(1180px,92vw);
      z-index:10;pointer-events:none;
    }
    .hud{
      pointer-events:auto;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:16px;
      padding:12px 14px;
      box-shadow:0 14px 60px rgba(0,0,0,.55);
      display:flex;flex-direction:column;gap:10px;
    }
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
    .hud-top{display:flex;justify-content:space-between;align-items:center;gap:12px;}
    .brand{display:flex;align-items:center;gap:10px;flex-wrap:wrap;}
    .dot{width:10px;height:10px;border-radius:999px;background:linear-gradient(135deg,var(--c1),var(--c2));box-shadow:0 0 18px rgba(112,0,255,.55);}
    .title{font-size:12px;text-transform:uppercase;letter-spacing:1px;color:var(--muted);}
    .pill{font-size:11px;color:rgba(255,255,255,.75);border:1px solid var(--border);padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.04);}
    .btn{
      border:1px solid var(--border);background:rgba(255,255,255,.06);color:var(--text);
      border-radius:12px;padding:10px 12px;font-weight:650;cursor:pointer;user-select:none;
      transition:transform .12s ease, background .12s ease;
    }
    .btn:hover{transform:translateY(-1px);background:rgba(255,255,255,.09);}
    .btn.primary{border:0;background:linear-gradient(135deg,var(--c1),var(--c2));box-shadow:0 0 22px rgba(0,242,255,.25);}
    .btn.danger{border:1px solid rgba(255,80,80,.3);background:rgba(255,80,80,.10);}

    input[type="range"]{-webkit-appearance:none;width:100%;height:4px;border-radius:99px;background:rgba(255,255,255,.2);outline:none;}
    input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:16px;height:16px;border-radius:50%;background:var(--c1);border:2px solid rgba(0,0,0,.35);}
    select,input[type="file"],input[type="text"]{
      border:1px solid var(--border);background:rgba(255,255,255,.06);color:var(--text);
      border-radius:12px;padding:10px 12px;outline:none;
    }
    input[type="text"]{min-width:190px;}

    details{border:1px solid var(--border);border-radius:14px;padding:10px 12px;background:rgba(255,255,255,.03);}
    summary{cursor:pointer;color:var(--muted);font-weight:700;letter-spacing:.8px;text-transform:uppercase;list-style:none;}
    summary::-webkit-details-marker{display:none;}
    .grid{margin-top:10px;display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:14px;}
    .group h4{margin:0 0 8px 0;font-size:11px;color:rgba(255,255,255,.55);text-transform:uppercase;letter-spacing:.6px;}
    .slider-row{display:flex;align-items:center;gap:10px;justify-content:space-between;margin:8px 0;}
    .slider-row label{min-width:92px;font-size:13px;color:rgba(255,255,255,.86);}
    .check-row{display:flex;align-items:center;gap:10px;user-select:none;}
    .check-row input{width:16px;height:16px;}

    #start-overlay{
      position:absolute;inset:0;background:rgba(0,0,0,.92);z-index:20;
      display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;padding:0 18px;
    }
    #start-btn{
      width:92px;height:92px;border-radius:50%;border:0;
      background:linear-gradient(135deg,var(--c1),var(--c2));
      color:#fff;cursor:pointer;display:flex;align-items:center;justify-content:center;
      box-shadow:0 0 40px rgba(112,0,255,.55);transition:transform .18s ease;
    }
    #start-btn:hover{transform:scale(1.06);}
    #start-sub{margin-top:16px;font-size:12px;letter-spacing:2px;text-transform:uppercase;color:rgba(255,255,255,.78);}
    #start-tip{margin-top:10px;font-size:12px;color:rgba(255,255,255,.55);max-width:980px;line-height:1.45;}
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
</head>

<body>
  <div id="start-overlay">
    <button id="start-btn" aria-label="Start">
      <svg viewBox="0 0 24 24" width="42" height="42" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
    </button>
    <div id="start-sub">Enter Cinema</div>
    <div id="start-tip">
      ✅ Wrist UI improvements:
      <b>FLOAT</b> mode (menu becomes world-floating), <b>grab & rotate</b> with <b>RIGHT-hand squeeze</b>, then <b>ATTACH</b> to save offsets to wrist.<br>
      ✅ More VR menu padding so nothing clips near edges.<br>
      ✅ Host can change video URL and it loads for everyone.
    </div>
  </div>

  <div id="canvas-container"></div>

  <div id="ui-layer">
    <div class="hud">
      <div class="hud-top">
        <div class="brand">
          <div class="dot"></div>
          <div class="title">VR Cinema</div>
          <span class="pill" id="perf-pill">Desktop</span>
          <span class="pill" id="net-pill" style="opacity:.85;">Offline</span>
        </div>
        <div class="row">
          <button class="btn primary" id="btn-play">Play</button>
          <button class="btn" id="btn-back">-10s</button>
          <button class="btn" id="btn-fwd">+10s</button>
          <button class="btn" id="btn-recenter">Center</button>
        </div>
      </div>

      <div class="row" style="gap:12px;">
        <input type="range" id="input-seek" min="0" max="1" step="0.001" value="0" style="flex:1;">
        <span class="pill" id="time-readout" style="min-width:170px; text-align:center;">00:00 / 00:00</span>
      </div>

      <div class="row" style="justify-content:space-between;">
        <div class="row" style="gap:10px; flex-wrap:wrap;">
          <select id="input-stereo-mode" title="Stereo Mode">
            <option value="mono">Mono (2D)</option>
            <option value="sbs">Side-by-Side (SBS)</option>
            <option value="ou">Over-Under (Top/Bottom)</option>
          </select>

          <label class="check-row"><input type="checkbox" id="input-swap-eyes"><span>Swap Eyes</span></label>
          <label class="check-row"><input type="checkbox" id="input-fx-enabled"><span>Effects</span></label>
          <label class="check-row"><input type="checkbox" id="input-bg-reactive"><span>Reactive BG</span></label>

          <div class="row">
            <span style="font-size:13px;color:rgba(255,255,255,.75);">Vol</span>
            <input type="range" id="input-volume" min="0" max="1" step="0.01" value="1" style="width:160px;">
          </div>

          <input type="file" id="input-file" accept="video/*" />
          <button class="btn" id="btn-reset-video">Reset</button>
        </div>

        <span class="pill" style="opacity:.8;">Drag & drop video supported</span>
      </div>

      <details>
        <summary>Advanced</summary>

        <div class="grid">
          <div class="group">
            <h4>Watch Together (PeerJS)</h4>
            <div class="row" style="gap:10px;">
              <input type="text" id="input-room" placeholder="Room code (e.g. ABC123)" />
              <button class="btn" id="btn-host-room">Host</button>
              <button class="btn" id="btn-join-room">Join</button>
              <button class="btn danger" id="btn-leave-room">Leave</button>
            </div>
            <div style="margin-top:8px;font-size:12px;color:rgba(255,255,255,.6);line-height:1.35;">
              Status: <span id="room-status">Offline</span><br>
              Your Peer ID: <span id="peer-id" style="opacity:.85;">—</span>
            </div>

            <div style="margin-top:10px;">
              <div style="font-size:12px;color:rgba(255,255,255,.6);margin-bottom:6px;">
                Video URL (host broadcasts to room)
              </div>
              <div class="row" style="gap:10px;">
                <input type="text" id="input-video-url" placeholder="https://.../video.mp4" style="min-width:340px; flex:1;">
                <button class="btn" id="btn-load-url">Load URL</button>
              </div>
              <div style="margin-top:6px;font-size:12px;color:rgba(255,255,255,.55);line-height:1.35;">
                Current: <span id="current-video-url" style="opacity:.85;">(default)</span>
              </div>
            </div>
          </div>

          <div class="group">
            <h4>Screen</h4>
            <div class="slider-row"><label>Size</label><input type="range" id="input-scale" min="0.3" max="3.0" step="0.01" value="1.0"></div>
            <div class="slider-row"><label>Pos Y</label><input type="range" id="input-y" min="-4" max="4" step="0.1" value="0"></div>
            <div class="slider-row"><label>Z</label><input type="range" id="input-depth" min="-10" max="5" step="0.1" value="0"></div>
            <div class="slider-row"><label>Curve</label><input type="range" id="input-curve" min="-2" max="2" step="0.01" value="0"></div>
            <div class="slider-row"><label>Round</label><input type="range" id="input-radius" min="0" max="0.25" step="0.01" value="0.05"></div>
            <div class="slider-row"><label>Feather</label><input type="range" id="input-softness" min="0" max="0.15" step="0.005" value="0.03"></div>
            <div class="slider-row"><label>3D Depth</label><input type="range" id="input-parallax" min="-0.08" max="0.08" step="0.001" value="0"></div>
          </div>

          <div class="group">
            <h4>Effects</h4>
            <div class="slider-row"><label>Width</label><input type="range" id="input-fx-w" min="0.2" max="3.0" step="0.01" value="1.0"></div>
            <div class="slider-row"><label>Height</label><input type="range" id="input-fx-h" min="0.2" max="3.0" step="0.01" value="1.0"></div>
            <div class="slider-row"><label>Round</label><input type="range" id="input-fx-radius" min="0" max="0.25" step="0.01" value="0.05"></div>
            <div class="slider-row"><label>Feather</label><input type="range" id="input-fx-softness" min="0" max="0.15" step="0.005" value="0.03"></div>
            <div class="slider-row"><label>Intensity</label><input type="range" id="input-fx-intensity" min="0" max="1.2" step="0.01" value="0.55"></div>
            <div class="slider-row"><label>Blur</label><input type="range" id="input-fx-blur" min="0" max="3" step="0.01" value="1.35"></div>
          </div>

          <div class="group">
            <h4>Environment (World)</h4>
            <div class="slider-row"><label>Rot X</label><input type="range" id="input-env-rotx" min="-180" max="180" step="1" value="0"></div>
            <div class="slider-row"><label>Rot Y</label><input type="range" id="input-env-roty" min="-180" max="180" step="1" value="0"></div>
            <div class="slider-row"><label>Rot Z</label><input type="range" id="input-env-rotz" min="-180" max="180" step="1" value="0"></div>

            <div class="slider-row"><label>Sphere</label><input type="range" id="input-env-sphere" min="0.5" max="30.0" step="0.01" value="1.0"></div>
            <div class="slider-row"><label>Stars</label><input type="range" id="input-env-stars" min="0" max="1" step="0.01" value="1.0"></div>

            <div class="slider-row"><label>Pos X</label><input type="range" id="input-env-x" min="-200" max="200" step="0.1" value="0"></div>
            <div class="slider-row"><label>Pos Y</label><input type="range" id="input-env-y" min="-200" max="200" step="0.1" value="0"></div>
            <div class="slider-row"><label>Pos Z</label><input type="range" id="input-env-z" min="-200" max="200" step="0.1" value="0"></div>
          </div>

          <div class="group">
            <h4>Reactive Background</h4>
            <div class="slider-row"><label>Strength</label><input type="range" id="input-bg-strength" min="0" max="2" step="0.01" value="1.0"></div>
            <div class="slider-row"><label>Speed</label><input type="range" id="input-bg-speed" min="0.02" max="0.35" step="0.01" value="0.12"></div>
          </div>

          <div class="group">
            <h4>VR Wrist UI (Fit + Modes)</h4>
            <div class="row" style="gap:10px;margin-bottom:6px;">
              <button class="btn" id="btn-ui-float">Float</button>
              <button class="btn" id="btn-ui-attach">Attach</button>
              <button class="btn danger" id="btn-ui-reset">Reset</button>
              <span class="pill" id="ui-mode-pill">Mode: Wrist</span>
            </div>

            <div class="slider-row"><label>Pos X</label><input type="range" id="input-ui-posx" min="-0.12" max="0.12" step="0.001" value="0.02"></div>
            <div class="slider-row"><label>Pos Y</label><input type="range" id="input-ui-posy" min="-0.12" max="0.12" step="0.001" value="0.02"></div>
            <div class="slider-row"><label>Pos Z</label><input type="range" id="input-ui-posz" min="-0.12" max="0.12" step="0.001" value="0.08"></div>

            <div class="slider-row"><label>Rot X</label><input type="range" id="input-ui-rotx" min="-90" max="90" step="1" value="-25"></div>
            <div class="slider-row"><label>Rot Y</label><input type="range" id="input-ui-roty" min="-180" max="180" step="1" value="0"></div>
            <div class="slider-row"><label>Rot Z</label><input type="range" id="input-ui-rotz" min="-90" max="90" step="1" value="0"></div>

            <div style="margin-top:6px;font-size:12px;color:rgba(255,255,255,.55);line-height:1.35;">
              VR: <b>Float</b> → squeeze (right hand) to grab & rotate → <b>Attach</b> to save to wrist.
            </div>
          </div>

          <div class="group">
            <h4>Storage</h4>
            <div class="row">
              <button class="btn" id="btn-clear-settings">Clear Saved</button>
            </div>
            <div style="font-size:12px;color:rgba(255,255,255,.55);line-height:1.35;margin-top:8px;">
              Saves to localStorage + cookie fallback (30 days).
            </div>
          </div>
        </div>
      </details>
    </div>
  </div>

  <video id="video-source" loop crossOrigin="anonymous" playsinline preload="auto" style="display:none">
    <source id="video-default-src" src="https://192.168.1.22:8080/Arthur.mp4" type="video/mp4">
  </video>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { VRButton } from "three/addons/webxr/VRButton.js";

    // ===================== CONFIG =====================
    const config = {
      screenWidth: 16,
      screenHeight: 9,

      segDesktop: 64,
      segVR: 36,
      segFlat: 1,
      curveFlatThreshold: 0.06,

      baseDistanceDesktop: 5,
      vrScreenDistance: 3.0,

      xrFoveation: 1.0,
      xrScaleFactor: 0.85,

      // VR menu: more padding + larger canvas/plane so nothing clips
      menuCanvasW: 1100,
      menuCanvasH: 680,
      menuWorldW: 0.66,
      menuWorldH: 0.42,

      hudCanvasW: 768,
      hudCanvasH: 160,
      hudWorldW: 0.52,
      hudWorldH: 0.11,

      analyzerW: 32,
      analyzerH: 18,
      analyzerHzDesktop: 10,
      analyzerHzVR: 7,

      bgBase: new THREE.Color(0.08, 0.09, 0.12),

      cookieDays: 30,

      netSyncIntervalMs: 2000,
      netSeekThrottleMs: 250,
      netTimeSnapSec: 0.35
    };

    const STORE_KEY = "vr_cinema_settings_v11";
    const COOKIE_KEY = "vr_cinema_settings_v11";

    // ===================== STATE =====================
    const state = {
      version: 11,

      // screen (proportional)
      mScale: 1.0,
      mY: 0.0,
      mDepth: 0.0,
      mCurve: 0.0,
      mParallax: 0.0,
      mRadius: 0.05,
      mSoftness: 0.03,

      // stereo
      stereoMode: "mono",
      swapEyes: false,

      // playback
      paused: true,
      volume: 1.0,

      // effects overlay
      fxEnabled: false,
      fxScaleW: 1.0,
      fxScaleH: 1.0,
      fxRadius: 0.05,
      fxSoftness: 0.03,
      fxIntensity: 0.55,
      fxBlur: 1.35,

      // reactive bg
      bgReactive: true,
      bgStrength: 1.0,
      bgSpeed: 0.12,

      // env world
      envRotX: 0.0, envRotY: 0.0, envRotZ: 0.0,
      envSphere: 1.0,
      envStars: 1.0,
      envPosX: 0.0, envPosY: 0.0, envPosZ: 0.0,

      // wrist UI mode + transforms
      uiMode: "wrist", // "wrist" | "float"
      uiHandPosX: 0.02, uiHandPosY: 0.02, uiHandPosZ: 0.08,
      uiHandRotX: -25, uiHandRotY: 0, uiHandRotZ: 0,

      // world-floating transform (used when uiMode==="float")
      uiFloatPosX: 0.0, uiFloatPosY: 1.1, uiFloatPosZ: -1.2,
      uiFloatRotX: 0, uiFloatRotY: 0, uiFloatRotZ: 0,

      showFPS: true,
    };

    const uiState = {
      hoverId: null,
      activeId: null,
      dragging: false,
      menuVisible: false,
      _lastFrameMs: performance.now(),
      _fpsSmoothed: 0,
      _lastLabelTick: 0,
      _hudRects: [],
    };

    // ===================== VR MENU CONFIG =====================
    // More padding: padX/padY bigger, rowH slightly bigger, so edges never clip.
    const uiConfig = [
      // Col 0: Screen + Wrist
      { type:"section", label:"SCREEN", col:0, row:0 },
      { type:"slider", label:"SIZE",   param:"mScale",   min:0.3, max:3.0, step:0.01, col:0, row:1, fmt:(v)=>v.toFixed(2) },
      { type:"slider", label:"POS Y",  param:"mY",       min:-4,  max:4,   step:0.1,  col:0, row:2, fmt:(v)=>v.toFixed(1) },
      { type:"slider", label:"Z",      param:"mDepth",   min:-10, max:5,   step:0.1,  col:0, row:3, fmt:(v)=>v.toFixed(1) },
      { type:"slider", label:"CURVE",  param:"mCurve",   min:-2,  max:2,   step:0.01, col:0, row:4, fmt:(v)=>v.toFixed(2) },
      { type:"slider", label:"ROUND",  param:"mRadius",  min:0.0, max:0.25,step:0.01, col:0, row:5, fmt:(v)=>v.toFixed(2) },
      { type:"slider", label:"FEATHER",param:"mSoftness",min:0.0, max:0.15,step:0.005,col:0, row:6, fmt:(v)=>v.toFixed(3) },
      { type:"slider", label:"3D DEP", param:"mParallax",min:-0.08,max:0.08,step:0.001,col:0,row:7, fmt:(v)=>v.toFixed(3) },

      { type:"section", label:"WRIST UI", col:0, row:8 },
      { type:"buttonRow", id:"uimode", col:0, row:9, buttons:[
        { id:"float",  label:"FLOAT",  onPress:()=>setUIMode("float") },
        { id:"attach", label:"ATTACH", onPress:()=>setUIMode("wrist") },
        { id:"reset",  label:"RESET",  onPress:()=>resetWristOffsets() },
      ]},
      { type:"slider", label:"POS X", param:"uiHandPosX", min:-0.12, max:0.12, step:0.001, col:0, row:10, fmt:(v)=>v.toFixed(3) },
      { type:"slider", label:"POS Y", param:"uiHandPosY", min:-0.12, max:0.12, step:0.001, col:0, row:11, fmt:(v)=>v.toFixed(3) },
      { type:"slider", label:"POS Z", param:"uiHandPosZ", min:-0.12, max:0.12, step:0.001, col:0, row:12, fmt:(v)=>v.toFixed(3) },
      { type:"slider", label:"ROT X", param:"uiHandRotX", min:-90, max:90, step:1, col:0, row:13, fmt:(v)=>`${v.toFixed(0)}°` },
      { type:"slider", label:"ROT Y", param:"uiHandRotY", min:-180, max:180, step:1, col:0, row:14, fmt:(v)=>`${v.toFixed(0)}°` },
      { type:"slider", label:"ROT Z", param:"uiHandRotZ", min:-90, max:90, step:1, col:0, row:15, fmt:(v)=>`${v.toFixed(0)}°` },

      // Col 1: Effects + BG
      { type:"section", label:"EFFECTS", col:1, row:0 },
      { type:"toggle", label:"ENABLE", param:"fxEnabled", col:1, row:1 },
      { type:"slider", label:"W",     param:"fxScaleW",   min:0.2, max:3.0, step:0.01, col:1, row:2, fmt:(v)=>v.toFixed(2) },
      { type:"slider", label:"H",     param:"fxScaleH",   min:0.2, max:3.0, step:0.01, col:1, row:3, fmt:(v)=>v.toFixed(2) },
      { type:"slider", label:"ROUND", param:"fxRadius",   min:0.0, max:0.25,step:0.01, col:1, row:4, fmt:(v)=>v.toFixed(2) },
      { type:"slider", label:"FEATH", param:"fxSoftness", min:0.0, max:0.15,step:0.005,col:1, row:5, fmt:(v)=>v.toFixed(3) },
      { type:"slider", label:"INTENS",param:"fxIntensity",min:0.0, max:1.2, step:0.01, col:1, row:6, fmt:(v)=>v.toFixed(2) },
      { type:"slider", label:"BLUR",  param:"fxBlur",     min:0.0, max:3.0, step:0.01, col:1, row:7, fmt:(v)=>v.toFixed(2) },

      { type:"section", label:"BG MOOD", col:1, row:8 },
      { type:"toggle",  label:"ENABLE", param:"bgReactive", col:1, row:9 },
      { type:"slider",  label:"STR",    param:"bgStrength", min:0.0, max:2.0, step:0.01, col:1, row:10, fmt:(v)=>v.toFixed(2) },
      { type:"slider",  label:"SPEED",  param:"bgSpeed",    min:0.02, max:0.35, step:0.01, col:1, row:11, fmt:(v)=>v.toFixed(2) },

      // Col 2: Player + Env
      { type:"section", label:"PLAYER", col:2, row:0 },
      { type:"buttonRow", id:"modes", col:2, row:1, buttons:[
        { id:"mono", label:"2D",  onPress:()=>setStereo("mono") },
        { id:"sbs",  label:"SBS", onPress:()=>setStereo("sbs")  },
        { id:"ou",   label:"OU",  onPress:()=>setStereo("ou")   },
      ]},
      { type:"toggle", label:"SWAP", param:"swapEyes", col:2, row:2 },
      { type:"seek",   label:"SEEK", col:2, row:3 },
      { type:"buttonRow", id:"transport", col:2, row:4, buttons:[
        { id:"back", label:"-10", onPress:()=>seekBy(-10) },
        { id:"play", label:"PLAY",onPress:()=>togglePlay() },
        { id:"fwd",  label:"+10", onPress:()=>seekBy(10) },
      ]},
      { type:"buttonRow", id:"tools", col:2, row:5, buttons:[
        { id:"center", label:"CENTER", onPress:()=>recenterScreenRig(config.vrScreenDistance) },
        { id:"hand",   label:"MENU HAND", onPress:()=>toggleMenuHand() },
      ]},

      { type:"section", label:"ENV", col:2, row:6 },
      { type:"slider", label:"ROT X", param:"envRotX", min:-180, max:180, step:1, col:2, row:7, fmt:(v)=>`${v.toFixed(0)}°` },
      { type:"slider", label:"ROT Y", param:"envRotY", min:-180, max:180, step:1, col:2, row:8, fmt:(v)=>`${v.toFixed(0)}°` },
      { type:"slider", label:"ROT Z", param:"envRotZ", min:-180, max:180, step:1, col:2, row:9, fmt:(v)=>`${v.toFixed(0)}°` },
      { type:"slider", label:"SPHERE",param:"envSphere",min:0.5, max:30.0, step:0.01, col:2, row:10, fmt:(v)=>v.toFixed(2) },
      { type:"slider", label:"STARS", param:"envStars", min:0.0, max:1.0,  step:0.01, col:2, row:11, fmt:(v)=>v.toFixed(2) },
      { type:"slider", label:"POS X", param:"envPosX",  min:-200,max:200,  step:0.1, col:2, row:12, fmt:(v)=>v.toFixed(1) },
      { type:"slider", label:"POS Y", param:"envPosY",  min:-200,max:200,  step:0.1, col:2, row:13, fmt:(v)=>v.toFixed(1) },
      { type:"slider", label:"POS Z", param:"envPosZ",  min:-200,max:200,  step:0.1, col:2, row:14, fmt:(v)=>v.toFixed(1) },
    ];

    // ===================== THREE GLOBALS =====================
    let scene, camera, renderer, controls;
    const screenRig = new THREE.Group();
    let screenGeometry = null;

    // Video
    let videoElement, videoTexture, videoMesh, videoMaterial;
    let fxMesh, fxMaterial;

    // Environment
    const envGroup = new THREE.Group();
    let envBaseMat, envStarsMat;
    const bgSmoothed = new THREE.Color().copy(config.bgBase);
    const bgTarget = new THREE.Color().copy(config.bgBase);
    let bgLastUpdateMs = 0;
    let bgAnalyzerBroken = false;

    // Analyzer
    let analyzeCanvas, analyzeCtx;

    // XR / controllers
    let inVR = false;
    let xrLeftUUID = null, xrRightUUID = null;

    let controllerA, controllerB;
    let gripA, gripB;
    let menuController = null;
    let pointerController = null;
    let forceSwapHands = false;

    const raycaster = new THREE.Raycaster();
    const tempMatrix = new THREE.Matrix4();

    // Wrist UI group
    let wristUIGroup = null;

    // Grab in FLOAT mode (right-hand squeeze)
    const grabState = {
      active: false,
      controller: null,
      offset: new THREE.Matrix4(),
      invCtrl: new THREE.Matrix4(),
      tmp: new THREE.Matrix4(),
      p: new THREE.Vector3(),
      q: new THREE.Quaternion(),
      s: new THREE.Vector3(1,1,1),
      e: new THREE.Euler(0,0,0,"XYZ"),
    };

    // VR canvases
    let menuCanvas, menuCtx, menuTex, menuMesh;
    let hudCanvas, hudCtx, hudTex, hudMesh;
    let uiRects = [];
    let uiDirtyMenu = true;
    let uiDirtyHud = true;

    // ===================== PERSISTENCE =====================
    let saveTimer = null;
    function scheduleSave(immediate=false){
      if (immediate){
        if (saveTimer){ clearTimeout(saveTimer); saveTimer = null; }
        saveSettings();
        return;
      }
      if (saveTimer) return;
      saveTimer = setTimeout(()=>{ saveTimer = null; saveSettings(); }, 250);
    }

    function setCookie(name, value, days){
      try{
        const d = new Date();
        d.setTime(d.getTime() + days*24*60*60*1000);
        document.cookie = `${name}=${value};expires=${d.toUTCString()};path=/;SameSite=Lax`;
      }catch{}
    }
    function getCookie(name){
      try{
        const key = name + "=";
        for (let c of document.cookie.split(";")){
          c = c.trim();
          if (c.indexOf(key) === 0) return c.substring(key.length);
        }
      }catch{}
      return null;
    }
    function deleteCookie(name){
      try{ document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;SameSite=Lax`; }catch{}
    }

    function saveSettings(){
      const json = JSON.stringify(state);
      try{ localStorage.setItem(STORE_KEY, json); }catch{}
      try{
        const enc = encodeURIComponent(json);
        if (enc.length < 3500) setCookie(COOKIE_KEY, enc, config.cookieDays);
      }catch{}
    }

    function loadSettings(){
      let raw = null;
      try{ raw = localStorage.getItem(STORE_KEY); }catch{}
      if (!raw){
        const c = getCookie(COOKIE_KEY);
        if (c) { try{ raw = decodeURIComponent(c); }catch{} }
      }
      if (!raw) return;

      try{
        const data = JSON.parse(raw);
        if (!data || typeof data !== "object") return;
        for (const k of Object.keys(state)){
          if (data[k] !== undefined) state[k] = data[k];
        }
      }catch{}
    }

    // ===================== PEERJS =====================
    let peer = null;
    let isHost = false;
    let roomCode = null;
    let hostPeerId = null;
    const conns = new Map();
    let mainConn = null;

    let suppressNetwork = false;
    let lastSeekSentMs = 0;
    let lastHostSyncMs = 0;

    function sanitizeRoomCode(s){
      const t = (s || "").trim().toUpperCase().replace(/[^A-Z0-9_-]/g, "");
      return t.slice(0, 20);
    }
    function makePeerId(code){ return `vrcinema-${code}`; }
    function randomRoomCode(len=6){
      const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
      let out = "";
      for (let i=0;i<len;i++) out += chars[Math.floor(Math.random()*chars.length)];
      return out;
    }
    function updateNetUI(statusText){
      document.getElementById("net-pill").textContent = statusText;
      document.getElementById("room-status").textContent = statusText;
      uiDirtyMenu = true;
    }
    function setPeerIdUI(id){ document.getElementById("peer-id").textContent = id || "—"; }

    function disconnectRoom(){
      try{
        if (mainConn) { mainConn.close(); mainConn = null; }
        for (const c of conns.values()) { try{ c.close(); }catch{} }
        conns.clear();
        if (peer) { peer.destroy(); peer = null; }
      }catch{}
      isHost = false;
      roomCode = null;
      hostPeerId = null;
      updateNetUI("Offline");
      setPeerIdUI(null);
    }

    function setupPeerCommonHandlers(){
      peer.on("error", (err)=>{ console.warn("PeerJS error:", err); updateNetUI(`Error: ${err.type || "peer"}`); });
      peer.on("disconnected", ()=> updateNetUI("Disconnected"));
      peer.on("close", ()=> updateNetUI("Closed"));
    }

    function hostRoom(codeIn){
      disconnectRoom();
      isHost = true;
      roomCode = sanitizeRoomCode(codeIn);
      if (!roomCode) roomCode = randomRoomCode(6);
      document.getElementById("input-room").value = roomCode;

      hostPeerId = makePeerId(roomCode);
      // eslint-disable-next-line no-undef
      peer = new Peer(hostPeerId, { debug: 1 });
      setupPeerCommonHandlers();

      peer.on("open", (id)=>{ setPeerIdUI(id); updateNetUI(`Hosting: ${roomCode}`); });

      peer.on("connection", (conn)=>{
        conns.set(conn.peer, conn);
        updateNetUI(`Hosting: ${roomCode} • Guests: ${conns.size}`);
        setupConn(conn, true);
        sendFullState(conn);
      });
    }

    function joinRoom(codeIn){
      disconnectRoom();
      isHost = false;
      roomCode = sanitizeRoomCode(codeIn);
      if (!roomCode){ updateNetUI("Enter room code"); return; }
      hostPeerId = makePeerId(roomCode);

      // eslint-disable-next-line no-undef
      peer = new Peer(undefined, { debug: 1 });
      setupPeerCommonHandlers();

      peer.on("open", (id)=>{
        setPeerIdUI(id);
        updateNetUI(`Joining: ${roomCode}…`);
        const conn = peer.connect(hostPeerId, { reliable:true });
        mainConn = conn;
        setupConn(conn, false);
        conn.on("open", ()=>{ updateNetUI(`Connected: ${roomCode}`); sendToHost({ t:"request_state" }); });
      });
    }

    function setupConn(conn, hostSide){
      conn.on("data", (msg)=>{ try{ handleNetMessage(conn, msg, hostSide); }catch(e){ console.warn(e); } });
      conn.on("close", ()=>{
        if (hostSide){
          conns.delete(conn.peer);
          updateNetUI(`Hosting: ${roomCode || "—"} • Guests: ${conns.size}`);
        } else {
          updateNetUI("Disconnected");
        }
      });
      conn.on("error", (err)=>console.warn("Conn error:", err));
    }

    function sendToHost(msg){
      if (!mainConn || !mainConn.open) return;
      try{ mainConn.send(msg); }catch{}
    }

    function broadcast(msg, exceptPeerId=null){
      if (!isHost) return;
      for (const [pid, c] of conns.entries()){
        if (exceptPeerId && pid === exceptPeerId) continue;
        if (!c.open) continue;
        try{ c.send(msg); }catch{}
      }
    }

    function currentShareableURL(){
      const url = videoElement.currentSrc || videoElement.src || "";
      if (url.startsWith("blob:") || url.startsWith("data:")) return null;
      return url || null;
    }

    function sendFullState(conn){
      const url = currentShareableURL();
      const payload = { t:"state", url, time: videoElement.currentTime || 0, paused: videoElement.paused };
      try{ conn.send(payload); }catch{}
      if (!url){
        try{ conn.send({ t:"note", msg:"Host is using a local file (blob). Load same video manually; play/pause/seek will sync." }); }catch{}
      }
    }

    function applyRemotePlayback({ time, paused }){
      if (typeof time === "number" && isFinite(time)){
        const diff = Math.abs((videoElement.currentTime || 0) - time);
        if (diff > config.netTimeSnapSec) videoElement.currentTime = time;
      }
      if (typeof paused === "boolean"){
        if (paused && !videoElement.paused) videoElement.pause();
        if (!paused && videoElement.paused) videoElement.play().catch(()=>{});
      }
    }

    function handleNetMessage(conn, msg, hostSide){
      if (!msg || typeof msg !== "object") return;

      if (hostSide){
        if (msg.t === "request_state"){ sendFullState(conn); return; }

        if (msg.t === "load"){
          suppressNetwork = true;
          if (msg.url) loadVideoURL(msg.url, { time: msg.time ?? 0, paused: !!msg.paused, suppressNet:true });
          else applyRemotePlayback({ time: msg.time, paused: msg.paused });
          suppressNetwork = false;
          broadcast(msg, conn.peer);
          return;
        }

        if (msg.t === "play" || msg.t === "pause" || msg.t === "seek" || msg.t === "sync"){
          suppressNetwork = true;
          applyRemotePlayback({ time: msg.time, paused: msg.paused });
          suppressNetwork = false;
          broadcast(msg, conn.peer);
          return;
        }
        return;
      }

      // guest
      if (msg.t === "state"){
        suppressNetwork = true;
        const url = msg.url;
        const time = typeof msg.time === "number" ? msg.time : 0;
        const paused = !!msg.paused;
        if (url && (videoElement.currentSrc || videoElement.src) !== url) loadVideoURL(url, { time, paused, suppressNet:true });
        else applyRemotePlayback({ time, paused });
        suppressNetwork = false;
        return;
      }

      if (msg.t === "load"){
        suppressNetwork = true;
        if (msg.url) loadVideoURL(msg.url, { time: msg.time ?? 0, paused: !!msg.paused, suppressNet:true });
        else applyRemotePlayback({ time: msg.time, paused: msg.paused });
        suppressNetwork = false;
        return;
      }

      if (msg.t === "play" || msg.t === "pause" || msg.t === "seek" || msg.t === "sync"){
        suppressNetwork = true;
        applyRemotePlayback({ time: msg.time, paused: msg.paused });
        suppressNetwork = false;
        return;
      }
    }

    function emitNetAction(type){
      if (suppressNetwork) return;
      if (!peer || !roomCode) return;
      const payload = { t:type, time: videoElement.currentTime || 0, paused: videoElement.paused };
      if (isHost) broadcast(payload); else sendToHost(payload);
    }

    // Host-only broadcast for URL changes
    function emitNetLoad(){
      if (suppressNetwork) return;
      if (!peer || !roomCode) return;
      if (!isHost) return;
      const payload = { t:"load", url: currentShareableURL(), time: videoElement.currentTime || 0, paused: videoElement.paused };
      broadcast(payload);
    }

    // ===================== SHADERS =====================
    const sharedVertexShader = `
      varying vec2 vUv;
      uniform float uCurve;
      void main() {
        vUv = uv;
        vec3 pos = position;
        float curveAmount = uCurve * 0.08;
        pos.z -= pos.x * pos.x * curveAmount;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `;

    const stereoUvSnippet = `
      vec2 applyStereoUv(vec2 uv, float eyeIn, int stereoMode, int swapEyes, float parallax, out vec4 bounds) {
        bounds = vec4(0.0, 0.0, 1.0, 1.0);
        if (stereoMode == 0 || eyeIn < 0.0) return uv;

        float eye = eyeIn;
        if (swapEyes == 1) eye = 1.0 - eye;

        if (stereoMode == 1) {
          float x0 = (eye < 0.5) ? 0.0 : 0.5;
          float x1 = x0 + 0.5;
          bounds = vec4(x0, 0.0, x1, 1.0);
          uv.x = x0 + uv.x * 0.5;
        } else if (stereoMode == 2) {
          float y0 = (eye < 0.5) ? 0.5 : 0.0;
          float y1 = y0 + 0.5;
          bounds = vec4(0.0, y0, 1.0, y1);
          uv.y = y0 + uv.y * 0.5;
        }

        float dir = (eye < 0.5) ? -1.0 : 1.0;
        uv.x += dir * parallax;

        uv.x = clamp(uv.x, bounds.x + 0.0005, bounds.z - 0.0005);
        uv.y = clamp(uv.y, bounds.y + 0.0005, bounds.w - 0.0005);
        return uv;
      }
    `;

    const mainFragmentShader = `
      precision mediump float;
      uniform sampler2D uTexture;
      uniform float uRadius;
      uniform float uSoftness;

      uniform float uEye;
      uniform int uStereoMode;
      uniform int uSwapEyes;
      uniform float uParallax;

      varying vec2 vUv;

      float sdRoundedBox(in vec2 p, in vec2 b, in vec4 r) {
        r.xy = (p.x > 0.0) ? r.xy : r.zw;
        r.x  = (p.y > 0.0) ? r.x  : r.y;
        vec2 q = abs(p) - b + r.x;
        return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;
      }

      ${stereoUvSnippet}

      void main() {
        vec4 bounds;
        vec2 uvStereo = applyStereoUv(vUv, uEye, uStereoMode, uSwapEyes, uParallax, bounds);
        vec4 texColor = texture2D(uTexture, uvStereo);

        vec2 uv = vUv - 0.5;
        float d = sdRoundedBox(uv, vec2(0.5), vec4(uRadius));
        float alpha = 1.0 - smoothstep(-uSoftness, 0.0, d);

        gl_FragColor = vec4(texColor.rgb, texColor.a * alpha);
      }
    `;

    const fxFragmentShader = `
      precision mediump float;
      uniform sampler2D uTexture;
      uniform float uBlurAmount;
      uniform float uIntensity;

      uniform float uFxRadius;
      uniform float uFxSoftness;

      uniform float uEye;
      uniform int uStereoMode;
      uniform int uSwapEyes;
      uniform float uParallax;

      varying vec2 vUv;

      float sdRoundedBox(in vec2 p, in vec2 b, in vec4 r) {
        r.xy = (p.x > 0.0) ? r.xy : r.zw;
        r.x  = (p.y > 0.0) ? r.x  : r.y;
        vec2 q = abs(p) - b + r.x;
        return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;
      }

      ${stereoUvSnippet}

      void main() {
        vec4 bounds;
        vec2 uv0 = applyStereoUv(vUv, uEye, uStereoMode, uSwapEyes, uParallax, bounds);

        vec2 stepv = vec2(uBlurAmount * 0.005, uBlurAmount * 0.005);
        if (uStereoMode == 1) stepv.x *= 0.5;
        if (uStereoMode == 2) stepv.y *= 0.5;

        vec4 color = vec4(0.0);
        vec2 uva = clamp(uv0 + vec2(-stepv.x, 0.0), bounds.xy, bounds.zw);
        vec2 uvb = clamp(uv0, bounds.xy, bounds.zw);
        vec2 uvc = clamp(uv0 + vec2(stepv.x, 0.0), bounds.xy, bounds.zw);
        vec2 uvd = clamp(uv0 + vec2(0.0, -stepv.y), bounds.xy, bounds.zw);
        vec2 uve = clamp(uv0 + vec2(0.0, stepv.y), bounds.xy, bounds.zw);

        color += texture2D(uTexture, uva);
        color += texture2D(uTexture, uvb);
        color += texture2D(uTexture, uvc);
        color += texture2D(uTexture, uvd);
        color += texture2D(uTexture, uve);
        color /= 5.0;

        float vignette = 1.0 - length(vUv - 0.5) * 2.5;
        vignette = clamp(vignette, 0.0, 1.0);

        vec2 p = vUv - 0.5;
        float d = sdRoundedBox(p, vec2(0.5), vec4(uFxRadius));
        float mask = 1.0 - smoothstep(-uFxSoftness, 0.0, d);

        gl_FragColor = vec4(color.rgb * uIntensity, vignette * mask);
      }
    `;

    // ===================== INIT =====================
    init();

    function init(){
      const container = document.getElementById("canvas-container");

      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.03);
      scene.fog.color.copy(config.bgBase);

      camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 5000);
      camera.position.set(0,0,config.baseDistanceDesktop);

      renderer = new THREE.WebGLRenderer({ antialias:false, alpha:false, powerPreference:"high-performance" });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.xr.enabled = true;

      container.appendChild(renderer.domElement);
      document.body.appendChild(VRButton.createButton(renderer));

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.target.set(0,0,0);

      scene.add(envGroup);
      scene.add(screenRig);

      createEnvironmentDomes();
      createVideoAnalyzer();
      createVideoScreen();
      createEffectsOverlay();
      screenRig.add(fxMesh);
      screenRig.add(videoMesh);

      createVirtualCanvasUI();
      createControllers();
      setupDesktopUI();

      loadSettings();
      applyStateToScene(true);
      syncDesktopFromState();
      applyUIModeAndAttach(); // ensure correct mode after load
      updateCurrentVideoURLLabel();
      updateUIModePill();

      renderer.xr.addEventListener("sessionstart", onEnterVR);
      renderer.xr.addEventListener("sessionend", onExitVR);

      renderer.setAnimationLoop(animate);
      window.addEventListener("resize", onWindowResize);
      window.addEventListener("beforeunload", ()=>{ try{ disconnectRoom(); }catch{} });

      const startOverlay = document.getElementById("start-overlay");
      document.getElementById("start-btn").addEventListener("click", async () => {
        startOverlay.style.display = "none";
        try { await videoElement.play(); } catch {}
        updatePlayUI();
      });

      // Playback sync hooks
      videoElement.addEventListener("play", ()=>{
        state.paused = false;
        updatePlayUI();
        uiDirtyHud = true; uiDirtyMenu = true;
        if (!suppressNetwork) emitNetAction("play");
        scheduleSave();
      });

      videoElement.addEventListener("pause", ()=>{
        state.paused = true;
        updatePlayUI();
        uiDirtyHud = true; uiDirtyMenu = true;
        if (!suppressNetwork) emitNetAction("pause");
        scheduleSave();
      });

      videoElement.addEventListener("seeked", ()=>{
        const now = performance.now();
        if (now - lastSeekSentMs < config.netSeekThrottleMs) return;
        lastSeekSentMs = now;
        uiDirtyHud = true; uiDirtyMenu = true;
        if (!suppressNetwork) emitNetAction("seek");
      });

      updateNetUI("Offline");
    }

    // ===================== ENVIRONMENT =====================
    function createEnvironmentDomes(){
      const baseCanvas = document.createElement("canvas");
      baseCanvas.width = 256; baseCanvas.height = 256;
      const bctx = baseCanvas.getContext("2d");
      const g = bctx.createRadialGradient(128, 140, 10, 128, 140, 170);
      g.addColorStop(0, "rgba(22,22,44,1)");
      g.addColorStop(0.58, "rgba(6,6,14,1)");
      g.addColorStop(1, "rgba(0,0,0,1)");
      bctx.fillStyle = g;
      bctx.fillRect(0,0,256,256);

      const baseTex = new THREE.CanvasTexture(baseCanvas);
      baseTex.colorSpace = THREE.SRGBColorSpace;

      envBaseMat = new THREE.MeshBasicMaterial({
        map: baseTex,
        side: THREE.BackSide,
        fog: false,
        color: new THREE.Color().copy(config.bgBase)
      });

      const starCanvas = document.createElement("canvas");
      starCanvas.width = 256; starCanvas.height = 256;
      const sctx = starCanvas.getContext("2d");
      sctx.clearRect(0,0,256,256);
      for(let i=0;i<260;i++){
        const x = Math.random()*256, y = Math.random()*256;
        const a = 0.25 + Math.random()*0.75;
        const size = Math.random() < 0.06 ? 2 : 1;
        sctx.fillStyle = `rgba(255,255,255,${a})`;
        sctx.fillRect(x,y,size,size);
      }

      const starTex = new THREE.CanvasTexture(starCanvas);
      starTex.colorSpace = THREE.SRGBColorSpace;

      envStarsMat = new THREE.MeshBasicMaterial({
        map: starTex,
        side: THREE.BackSide,
        transparent: true,
        opacity: 1.0,
        fog: false,
        depthWrite: false,
        depthTest: false,
        color: new THREE.Color(1,1,1)
      });

      const geo = new THREE.SphereGeometry(80, 20, 14);
      envGroup.add(new THREE.Mesh(geo, envBaseMat));
      envGroup.add(new THREE.Mesh(geo, envStarsMat));
    }

    // ===================== ANALYZER =====================
    function createVideoAnalyzer(){
      analyzeCanvas = document.createElement("canvas");
      analyzeCanvas.width = config.analyzerW;
      analyzeCanvas.height = config.analyzerH;
      analyzeCtx = analyzeCanvas.getContext("2d", { willReadFrequently:true, alpha:false });
    }

    function updateReactiveBackground(nowMs){
      if (!state.bgReactive || bgAnalyzerBroken || !envBaseMat) {
        bgTarget.copy(config.bgBase);
        bgSmoothed.lerp(bgTarget, 0.06);
        envBaseMat.color.copy(bgSmoothed);
        scene.fog.color.copy(bgSmoothed).multiplyScalar(0.35);
        return;
      }

      const hz = inVR ? config.analyzerHzVR : config.analyzerHzDesktop;
      const interval = 1000 / hz;
      if (nowMs - bgLastUpdateMs < interval) return;
      bgLastUpdateMs = nowMs;

      if (!videoElement || videoElement.readyState < 2) return;

      const w = analyzeCanvas.width, h = analyzeCanvas.height;
      try {
        analyzeCtx.drawImage(videoElement, 0, 0, w, h);
        const img = analyzeCtx.getImageData(0, 0, w, h).data;

        let sumR = 0, sumG = 0, sumB = 0, sumW = 0;
        let maxLum = 0, maxR = 0, maxG = 0, maxB = 0;

        for (let i = 0; i < img.length; i += 4) {
          const r = img[i] / 255, g = img[i+1] / 255, b = img[i+2] / 255;
          const lum = 0.2126*r + 0.7152*g + 0.0722*b;

          if (lum > maxLum) { maxLum = lum; maxR = r; maxG = g; maxB = b; }

          const wgt = (lum*lum) + 0.003;
          sumR += r*wgt; sumG += g*wgt; sumB += b*wgt; sumW += wgt;
        }

        const avgR = sumR / sumW, avgG = sumG / sumW, avgB = sumB / sumW;
        const mixBright = 0.62;

        const mR = avgR*(1-mixBright) + maxR*mixBright;
        const mG = avgG*(1-mixBright) + maxG*mixBright;
        const mB = avgB*(1-mixBright) + maxB*mixBright;

        const floor = 0.08;
        const intensity = Math.max(floor, Math.pow(maxLum, 0.5)) * state.bgStrength;
        const scale = 0.55 + 1.55 * clamp01(intensity / 1.1);

        bgTarget.setRGB(mR, mG, mB).multiplyScalar(scale);
        bgTarget.add(config.bgBase.clone().multiplyScalar(0.35));

        const a = clamp(state.bgSpeed, 0.02, 0.35);
        bgSmoothed.lerp(bgTarget, a);

        envBaseMat.color.copy(bgSmoothed);
        scene.fog.color.copy(bgSmoothed).multiplyScalar(0.35);

      } catch (e) {
        bgAnalyzerBroken = true;
        state.bgReactive = false;
        uiDirtyMenu = true; uiDirtyHud = true;
        syncDesktopFromState();
        scheduleSave(true);
      }
    }

    // ===================== SCREEN GEOMETRY LOD =====================
    function desiredSegments(){
      const curve = Math.abs(state.mCurve);
      if (curve < config.curveFlatThreshold) return config.segFlat;
      return inVR ? config.segVR : config.segDesktop;
    }
    function buildScreenGeometry(segX){
      const segY = Math.max(1, Math.round(segX * (config.screenHeight/config.screenWidth)));
      return new THREE.PlaneGeometry(config.screenWidth, config.screenHeight, segX, segY);
    }
    function setScreenGeometry(segX){
      if (screenGeometry) screenGeometry.dispose();
      screenGeometry = buildScreenGeometry(segX);
      videoMesh.geometry = screenGeometry;
      fxMesh.geometry = screenGeometry;
    }
    function updateScreenGeometryLOD(){
      const seg = desiredSegments();
      const curSeg = screenGeometry?.parameters?.widthSegments ?? -1;
      if (curSeg !== seg) setScreenGeometry(seg);
    }

    // ===================== VIDEO / FX =====================
    function createVideoScreen(){
      videoElement = document.getElementById("video-source");

      videoTexture = new THREE.VideoTexture(videoElement);
      videoTexture.colorSpace = THREE.SRGBColorSpace;
      videoTexture.minFilter = THREE.LinearFilter;
      videoTexture.magFilter = THREE.LinearFilter;
      videoTexture.generateMipmaps = false;

      videoMaterial = new THREE.ShaderMaterial({
        uniforms:{
          uTexture:{ value: videoTexture },
          uCurve:{ value: state.mCurve },
          uRadius:{ value: state.mRadius },
          uSoftness:{ value: state.mSoftness },
          uEye:{ value:-1.0 },
          uStereoMode:{ value: 0 },
          uSwapEyes:{ value: 0 },
          uParallax:{ value: state.mParallax }
        },
        vertexShader: sharedVertexShader,
        fragmentShader: mainFragmentShader,
        transparent:true,
        side:THREE.DoubleSide
      });

      screenGeometry = buildScreenGeometry(desiredSegments());
      videoMesh = new THREE.Mesh(screenGeometry, videoMaterial);
      videoMesh.onBeforeRender = (r,s,cam)=>setEyeUniform(videoMaterial, cam);
    }

    function createEffectsOverlay(){
      fxMaterial = new THREE.ShaderMaterial({
        uniforms:{
          uTexture:{ value: videoTexture },
          uCurve:{ value: state.mCurve },
          uBlurAmount:{ value: state.fxBlur },
          uIntensity:{ value: state.fxIntensity },

          uFxRadius:{ value: state.fxRadius },
          uFxSoftness:{ value: state.fxSoftness },

          uEye:{ value:-1.0 },
          uStereoMode:{ value: 0 },
          uSwapEyes:{ value: 0 },
          uParallax:{ value: state.mParallax }
        },
        vertexShader: sharedVertexShader,
        fragmentShader: fxFragmentShader,
        transparent:true,
        side:THREE.DoubleSide,
        depthWrite:false,
        depthTest:false
      });

      fxMesh = new THREE.Mesh(screenGeometry, fxMaterial);
      fxMesh.position.z = -1.5;
      fxMesh.visible = !!state.fxEnabled;
      fxMesh.onBeforeRender = (r,s,cam)=>setEyeUniform(fxMaterial, cam);
    }

    // ===================== XR EYE UNIFORMS =====================
    function updateXRCameraRefs(){
      const xrCam = renderer.xr.getCamera(camera);
      if (xrCam && xrCam.isArrayCamera && xrCam.cameras && xrCam.cameras.length >= 2) {
        xrLeftUUID = xrCam.cameras[0].uuid;
        xrRightUUID = xrCam.cameras[1].uuid;
      } else {
        xrLeftUUID = null;
        xrRightUUID = null;
      }
    }
    function setEyeUniform(material, cam){
      if (xrLeftUUID && cam?.uuid) {
        if (cam.uuid === xrLeftUUID) material.uniforms.uEye.value = 0.0;
        else if (cam.uuid === xrRightUUID) material.uniforms.uEye.value = 1.0;
        else material.uniforms.uEye.value = -1.0;
      } else {
        material.uniforms.uEye.value = -1.0;
      }
    }

    // ===================== WRIST UI MODE =====================
    function updateUIModePill(){
      const pill = document.getElementById("ui-mode-pill");
      pill.textContent = `Mode: ${state.uiMode === "float" ? "Float" : "Wrist"}`;
    }

    function resetWristOffsets(){
      state.uiMode = "wrist";
      state.uiHandPosX = 0.02; state.uiHandPosY = 0.02; state.uiHandPosZ = 0.08;
      state.uiHandRotX = -25; state.uiHandRotY = 0; state.uiHandRotZ = 0;

      applyUIModeAndAttach();
      scheduleSave(true);
      updateUIModePill();
      uiDirtyMenu = true; uiDirtyHud = true;
    }

    function setUIMode(mode){
      if (!wristUIGroup) return;

      const menuGrip = menuController?.userData?.grip || null;

      if (mode === "float" && state.uiMode !== "float") {
        // Convert current wrist UI world transform into float values and detach to scene
        wristUIGroup.updateMatrixWorld(true);
        const w = wristUIGroup.matrixWorld.clone();
        const p = new THREE.Vector3(), q = new THREE.Quaternion(), s = new THREE.Vector3();
        w.decompose(p,q,s);

        state.uiFloatPosX = p.x; state.uiFloatPosY = p.y; state.uiFloatPosZ = p.z;
        const e = new THREE.Euler().setFromQuaternion(q, "XYZ");
        state.uiFloatRotX = THREE.MathUtils.radToDeg(e.x);
        state.uiFloatRotY = THREE.MathUtils.radToDeg(e.y);
        state.uiFloatRotZ = THREE.MathUtils.radToDeg(e.z);

        // Detach to scene
        if (wristUIGroup.parent) wristUIGroup.parent.remove(wristUIGroup);
        scene.add(wristUIGroup);

        state.uiMode = "float";
        applyUIModeAndAttach();
        scheduleSave(true);
        updateUIModePill();
        return;
      }

      if (mode === "wrist" && state.uiMode !== "wrist") {
        // Convert current float world transform to grip-local offsets and attach
        if (!menuGrip) {
          // If no grip yet, just switch mode; will attach when grip exists
          state.uiMode = "wrist";
          scheduleSave(true);
          updateUIModePill();
          return;
        }

        wristUIGroup.updateMatrixWorld(true);
        menuGrip.updateMatrixWorld(true);

        const invGrip = new THREE.Matrix4().copy(menuGrip.matrixWorld).invert();
        const local = new THREE.Matrix4().multiplyMatrices(invGrip, wristUIGroup.matrixWorld);

        const p = new THREE.Vector3(), q = new THREE.Quaternion(), s = new THREE.Vector3();
        local.decompose(p,q,s);
        const e = new THREE.Euler().setFromQuaternion(q, "XYZ");

        state.uiHandPosX = clamp(p.x, -0.12, 0.12);
        state.uiHandPosY = clamp(p.y, -0.12, 0.12);
        state.uiHandPosZ = clamp(p.z, -0.12, 0.12);

        state.uiHandRotX = THREE.MathUtils.radToDeg(e.x);
        state.uiHandRotY = THREE.MathUtils.radToDeg(e.y);
        state.uiHandRotZ = THREE.MathUtils.radToDeg(e.z);

        state.uiMode = "wrist";
        applyUIModeAndAttach();
        scheduleSave(true);
        updateUIModePill();
        syncDesktopFromState();
        return;
      }

      // Same mode: just re-apply
      applyUIModeAndAttach();
      updateUIModePill();
    }

    function applyUIModeAndAttach(){
      if (!wristUIGroup) return;

      const menuGrip = menuController?.userData?.grip || null;

      if (state.uiMode === "float") {
        // Ensure it is a scene child
        if (wristUIGroup.parent !== scene) {
          if (wristUIGroup.parent) wristUIGroup.parent.remove(wristUIGroup);
          scene.add(wristUIGroup);
        }
        wristUIGroup.position.set(state.uiFloatPosX, state.uiFloatPosY, state.uiFloatPosZ);
        wristUIGroup.rotation.set(
          THREE.MathUtils.degToRad(state.uiFloatRotX),
          THREE.MathUtils.degToRad(state.uiFloatRotY),
          THREE.MathUtils.degToRad(state.uiFloatRotZ)
        );
        return;
      }

      // Wrist mode
      if (menuGrip) {
        if (wristUIGroup.parent !== menuGrip) {
          if (wristUIGroup.parent) wristUIGroup.parent.remove(wristUIGroup);
          menuGrip.add(wristUIGroup);
        }
      }
      wristUIGroup.position.set(state.uiHandPosX, state.uiHandPosY, state.uiHandPosZ);
      wristUIGroup.rotation.set(
        THREE.MathUtils.degToRad(state.uiHandRotX),
        THREE.MathUtils.degToRad(state.uiHandRotY),
        THREE.MathUtils.degToRad(state.uiHandRotZ)
      );
    }

    // ===================== VR GRAB (FLOAT MODE) =====================
    function tryStartGrab(controller){
      if (state.uiMode !== "float") return false;
      if (!wristUIGroup || !controller) return false;

      // Raycast to HUD/MENU (children of wristUIGroup)
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

      const hits = raycaster.intersectObjects([hudMesh, menuMesh], false);
      if (!hits.length) return false;

      grabState.active = true;
      grabState.controller = controller;

      controller.updateMatrixWorld(true);
      wristUIGroup.updateMatrixWorld(true);

      grabState.invCtrl.copy(controller.matrixWorld).invert();
      grabState.offset.multiplyMatrices(grabState.invCtrl, wristUIGroup.matrixWorld); // offset in controller space

      return true;
    }

    function updateGrab(){
      if (!grabState.active || !grabState.controller || !wristUIGroup) return;
      if (state.uiMode !== "float") { stopGrab(true); return; }

      grabState.controller.updateMatrixWorld(true);

      // wristWorld = controllerWorld * offset
      grabState.tmp.multiplyMatrices(grabState.controller.matrixWorld, grabState.offset);
      grabState.tmp.decompose(grabState.p, grabState.q, grabState.s);

      wristUIGroup.position.copy(grabState.p);
      wristUIGroup.quaternion.copy(grabState.q);
      wristUIGroup.scale.copy(grabState.s);

      // Update float state live (no spam save; save on release)
      state.uiFloatPosX = wristUIGroup.position.x;
      state.uiFloatPosY = wristUIGroup.position.y;
      state.uiFloatPosZ = wristUIGroup.position.z;

      grabState.e.setFromQuaternion(wristUIGroup.quaternion, "XYZ");
      state.uiFloatRotX = THREE.MathUtils.radToDeg(grabState.e.x);
      state.uiFloatRotY = THREE.MathUtils.radToDeg(grabState.e.y);
      state.uiFloatRotZ = THREE.MathUtils.radToDeg(grabState.e.z);

      uiDirtyHud = true;
      uiDirtyMenu = true;
    }

    function stopGrab(save){
      grabState.active = false;
      grabState.controller = null;
      if (save) scheduleSave(true);
    }

    // ===================== CANVAS UI =====================
    function createVirtualCanvasUI(){
      // Menu canvas
      menuCanvas = document.createElement("canvas");
      menuCanvas.width = config.menuCanvasW;
      menuCanvas.height = config.menuCanvasH;
      menuCtx = menuCanvas.getContext("2d", { alpha:true });

      menuTex = new THREE.CanvasTexture(menuCanvas);
      menuTex.colorSpace = THREE.SRGBColorSpace;
      menuTex.generateMipmaps = false;
      menuTex.minFilter = THREE.LinearFilter;
      menuTex.magFilter = THREE.LinearFilter;

      const menuMat = new THREE.MeshBasicMaterial({ map: menuTex, transparent:true, side:THREE.DoubleSide });
      menuMat.depthTest = false;
      menuMat.depthWrite = false;

      menuMesh = new THREE.Mesh(new THREE.PlaneGeometry(config.menuWorldW, config.menuWorldH), menuMat);
      menuMesh.visible = false;

      // HUD canvas
      hudCanvas = document.createElement("canvas");
      hudCanvas.width = config.hudCanvasW;
      hudCanvas.height = config.hudCanvasH;
      hudCtx = hudCanvas.getContext("2d", { alpha:true });

      hudTex = new THREE.CanvasTexture(hudCanvas);
      hudTex.colorSpace = THREE.SRGBColorSpace;
      hudTex.generateMipmaps = false;
      hudTex.minFilter = THREE.LinearFilter;
      hudTex.magFilter = THREE.LinearFilter;

      const hudMat = new THREE.MeshBasicMaterial({ map: hudTex, transparent:true, side:THREE.DoubleSide });
      hudMat.depthTest = false;
      hudMat.depthWrite = false;

      hudMesh = new THREE.Mesh(new THREE.PlaneGeometry(config.hudWorldW, config.hudWorldH), hudMat);
      hudMesh.visible = true;

      // Wrist group contains HUD + Menu
      wristUIGroup = new THREE.Group();
      wristUIGroup.name = "wristUIGroup";

      // Face forward in local space
      hudMesh.rotation.set(0, 0, 0);
      menuMesh.rotation.set(0, 0, 0);

      // Layout (HUD above, menu below)
      hudMesh.position.set(0.0, 0.065, 0.0);
      menuMesh.position.set(0.0, -0.085, 0.0); // slightly lower to give more separation
      wristUIGroup.add(hudMesh);
      wristUIGroup.add(menuMesh);

      uiRects = buildUIRects(uiConfig, config.menuCanvasW, config.menuCanvasH);

      uiDirtyMenu = true;
      uiDirtyHud = true;
      drawHUD({ force:true });
      drawMenu({ force:true });
    }

    function buildUIRects(uiConfig, width, height){
      const colW = width / 3;

      // More padding so nothing clips
      const rowH = 34;
      const padX = 28;
      const padY = 104;

      const rects = [];
      for (const item of uiConfig){
        const x0 = item.col * colW + padX;
        const y0 = padY + item.row * rowH;

        if (item.type === "section") {
          rects.push({ id:`section:${item.label}`, type:"section", item, x:x0, y:y0, w:colW-2*padX, h:22 });
          continue;
        }

        if (item.type === "slider") {
          const trackX = x0 + 112;
          const trackW = (colW - 2*padX) - 140;
          rects.push({
            id: item.param,
            type: "slider",
            item,
            x:x0, y:y0, w:colW-2*padX, h:rowH,
            track:{ x:trackX, y:y0+18, w:trackW, h:8 }
          });
          continue;
        }

        if (item.type === "toggle") {
          rects.push({ id:item.param, type:"toggle", item, x:x0, y:y0, w:colW-2*padX, h:rowH });
          continue;
        }

        if (item.type === "seek") {
          rects.push({
            id:"seek",
            type:"seek",
            item,
            x:x0, y:y0, w:colW-2*padX, h:rowH,
            track:{ x:x0+64, y:y0+18, w:(colW-2*padX)-92, h:8 }
          });
          continue;
        }

        if (item.type === "buttonRow") {
          const gap = 12;
          const bw = Math.floor((colW - 2*padX - gap*(item.buttons.length-1)) / item.buttons.length);
          const by = y0 + 5;
          const buttons = item.buttons.map((b, i)=>({
            id:`${item.id}:${b.id}`,
            baseId:item.id,
            btnId:b.id,
            label:b.label,
            onPress:b.onPress,
            x:x0 + i*(bw+gap),
            y:by,
            w:bw,
            h:24,
          }));
          rects.push({ id:item.id, type:"buttonRow", item, x:x0, y:y0, w:colW-2*padX, h:rowH, buttons });
          continue;
        }
      }
      return rects;
    }

    function drawMenu({force=false}={}){
      if (!uiDirtyMenu && !force) return;
      uiDirtyMenu = false;

      const ctx = menuCtx;
      const W = menuCanvas.width, H = menuCanvas.height;

      ctx.clearRect(0,0,W,H);

      // More inner padding so edges never clip
      const m = 18;

      ctx.fillStyle = "rgba(15,16,32,0.92)";
      roundRect(ctx, m, m, W-2*m, H-2*m, 18);
      ctx.fill();

      // Title
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.font = "700 26px Inter, system-ui, sans-serif";
      ctx.fillText("VR CINEMA", 30, 54);

      // Small mode line
      ctx.font = "700 13px Inter, system-ui, sans-serif";
      if (state.uiMode === "float") {
        ctx.fillStyle = "rgba(0,242,255,0.75)";
        ctx.fillText("UI: FLOAT (RIGHT SQUEEZE TO GRAB)", 30, 78);
      } else {
        ctx.fillStyle = "rgba(255,255,255,0.55)";
        ctx.fillText("UI: WRIST", 30, 78);
      }

      // Room line (if any)
      if (roomCode){
        ctx.fillStyle = "rgba(255,255,255,0.45)";
        ctx.fillText(isHost ? `ROOM ${roomCode} (HOST)` : `ROOM ${roomCode} (GUEST)`, 30, 98);
      }

      // FPS
      if (state.showFPS){
        ctx.font = "700 20px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
        ctx.fillStyle = "rgba(0,242,255,0.95)";
        ctx.textAlign = "right";
        ctx.fillText(`${uiState._fpsSmoothed.toFixed(0)} FPS`, W-30, 54);
        ctx.textAlign = "left";
      }

      // Separator
      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(24, 112); ctx.lineTo(W-24, 112); ctx.stroke();

      for (const r of uiRects) drawMenuItem(ctx, r);

      menuTex.needsUpdate = true;
    }

    function drawMenuItem(ctx, r){
      const hovered = uiState.menuVisible && uiState.hoverId === r.id;

      if (r.type === "section"){
        ctx.fillStyle = "rgba(255,255,255,0.38)";
        ctx.font = "700 14px Inter, system-ui, sans-serif";
        ctx.fillText(r.item.label, r.x, r.y + 15);
        return;
      }

      if (r.type === "slider"){
        ctx.font = "700 13px Inter, system-ui, sans-serif";
        ctx.fillStyle = "rgba(255,255,255,0.85)";
        ctx.fillText(r.item.label, r.x, r.y + 23);

        ctx.fillStyle = hovered ? "rgba(255,255,255,0.18)" : "rgba(255,255,255,0.12)";
        roundRect(ctx, r.track.x, r.track.y, r.track.w, 6, 6); ctx.fill();

        const t = (state[r.item.param] - r.item.min) / (r.item.max - r.item.min);
        const tt = clamp01(t);
        const fillW = tt * r.track.w;

        ctx.fillStyle = "rgba(0,242,255,0.75)";
        roundRect(ctx, r.track.x, r.track.y, fillW, 6, 6); ctx.fill();

        const hx = r.track.x + fillW;
        const hy = r.track.y + 3;
        ctx.beginPath(); ctx.arc(hx, hy, 6.5, 0, Math.PI*2);
        ctx.fillStyle = "rgba(0,242,255,1)";
        ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,0.72)";
        ctx.textAlign = "right";
        const fmt = r.item.fmt ?? ((v)=>String(v));
        ctx.fillText(fmt(state[r.item.param]), r.x + r.w - 8, r.y + 23);
        ctx.textAlign = "left";

        if (hovered){
          ctx.strokeStyle = "rgba(0,242,255,0.55)";
          ctx.lineWidth = 2;
          roundRect(ctx, r.x-8, r.y+4, r.w+16, r.h-8, 10);
          ctx.stroke();
        }
        return;
      }

      if (r.type === "toggle"){
        ctx.font = "700 13px Inter, system-ui, sans-serif";
        ctx.fillStyle = "rgba(255,255,255,0.85)";
        ctx.fillText(r.item.label, r.x, r.y + 23);

        const on = !!state[r.item.param];
        const bx = r.x + r.w - 74;
        const by = r.y + 7;

        ctx.fillStyle = on ? "rgba(0,242,255,0.8)" : "rgba(255,255,255,0.12)";
        roundRect(ctx, bx, by, 56, 18, 9); ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,0.92)";
        ctx.beginPath(); ctx.arc(on ? bx+42 : bx+14, by+9, 8, 0, Math.PI*2);
        ctx.fill();

        if (hovered){
          ctx.strokeStyle = "rgba(0,242,255,0.55)";
          ctx.lineWidth = 2;
          roundRect(ctx, r.x-8, r.y+4, r.w+16, r.h-8, 10);
          ctx.stroke();
        }
        return;
      }

      if (r.type === "seek"){
        ctx.font = "700 13px Inter, system-ui, sans-serif";
        ctx.fillStyle = "rgba(255,255,255,0.85)";
        ctx.fillText(r.item.label, r.x, r.y + 23);

        const timeStr = `${fmtTime(videoElement.currentTime)} / ${fmtTime(videoElement.duration)}`;
        ctx.fillStyle = "rgba(255,255,255,0.60)";
        ctx.textAlign = "right";
        ctx.font = "700 12px Inter, system-ui, sans-serif";
        ctx.fillText(timeStr, r.x + r.w - 8, r.y + 23);
        ctx.textAlign = "left";

        ctx.fillStyle = hovered ? "rgba(255,255,255,0.18)" : "rgba(255,255,255,0.12)";
        roundRect(ctx, r.track.x, r.track.y, r.track.w, 6, 6); ctx.fill();

        const dur = videoElement.duration;
        const t = (isFinite(dur) && dur > 0) ? clamp01(videoElement.currentTime / dur) : 0;
        const fillW = t * r.track.w;

        ctx.fillStyle = "rgba(0,242,255,0.75)";
        roundRect(ctx, r.track.x, r.track.y, fillW, 6, 6); ctx.fill();

        const hx = r.track.x + fillW;
        const hy = r.track.y + 3;
        ctx.beginPath(); ctx.arc(hx, hy, 6.5, 0, Math.PI*2);
        ctx.fillStyle = "rgba(0,242,255,1)";
        ctx.fill();

        if (hovered){
          ctx.strokeStyle = "rgba(0,242,255,0.55)";
          ctx.lineWidth = 2;
          roundRect(ctx, r.x-8, r.y+4, r.w+16, r.h-8, 10);
          ctx.stroke();
        }
        return;
      }

      if (r.type === "buttonRow"){
        for (const b of r.buttons){
          const bHovered = uiState.menuVisible && uiState.hoverId === b.id;
          const active = isButtonActive(b);

          ctx.fillStyle = active ? "rgba(0,242,255,0.90)" : (bHovered ? "rgba(255,255,255,0.14)" : "rgba(255,255,255,0.10)");
          roundRect(ctx, b.x, b.y, b.w, b.h, 10); ctx.fill();

          ctx.fillStyle = active ? "rgba(0,0,0,0.9)" : "rgba(255,255,255,0.88)";
          ctx.font = "700 13px Inter, system-ui, sans-serif";
          ctx.textAlign = "center";
          ctx.fillText(buttonLabelFor(b), b.x + b.w/2, b.y + 16);
          ctx.textAlign = "left";
        }
      }
    }

    function drawHUD({force=false}={}){
      if (!uiDirtyHud && !force) return;
      uiDirtyHud = false;

      const ctx = hudCtx;
      const W = hudCanvas.width, H = hudCanvas.height;

      ctx.clearRect(0,0,W,H);

      ctx.fillStyle = "rgba(15,16,32,0.88)";
      roundRect(ctx, 10, 10, W-20, H-20, 18); ctx.fill();

      ctx.fillStyle = "rgba(255,255,255,0.90)";
      ctx.font = "700 18px Inter, system-ui, sans-serif";
      ctx.fillText("HUD", 24, 40);

      ctx.font = "700 14px Inter, system-ui, sans-serif";
      ctx.fillStyle = "rgba(255,255,255,0.65)";
      ctx.textAlign = "right";
      ctx.fillText(`${fmtTime(videoElement.currentTime)} / ${fmtTime(videoElement.duration)}`, W-24, 40);
      ctx.textAlign = "left";

      const btns = [
        { id:"hud:menu", label:"MENU" },
        { id:"hud:back", label:"-10" },
        { id:"hud:play", label: state.paused ? "PLAY" : "PAUSE" },
        { id:"hud:fwd", label:"+10" },
        { id:"hud:mode", label: state.stereoMode === "mono" ? "2D" : (state.stereoMode === "sbs" ? "SBS" : "OU") },
      ];

      const x0 = 24, y0 = 64, bw = Math.floor((W - 48 - 4*12)/5), bh = 54, gap = 12;

      uiState._hudRects = btns.map((b,i)=>({ id:b.id, x:x0+i*(bw+gap), y:y0, w:bw, h:bh, label:b.label }));

      for (const b of uiState._hudRects){
        const hovered = uiState.hoverId === b.id;
        ctx.fillStyle = hovered ? "rgba(255,255,255,0.14)" : "rgba(255,255,255,0.10)";
        roundRect(ctx, b.x, b.y, b.w, b.h, 14); ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,0.90)";
        ctx.font = "700 16px Inter, system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(b.label, b.x + b.w/2, b.y + 32);
        ctx.textAlign = "left";
      }

      hudTex.needsUpdate = true;
    }

    // ===================== CONTROLLERS (GRIP + GRAB) =====================
    function createControllers(){
      controllerA = renderer.xr.getController(0);
      controllerB = renderer.xr.getController(1);

      gripA = renderer.xr.getControllerGrip(0);
      gripB = renderer.xr.getControllerGrip(1);
      scene.add(gripA);
      scene.add(gripB);

      controllerA.userData.grip = gripA;
      controllerB.userData.grip = gripB;

      setupController(controllerA);
      setupController(controllerB);

      scene.add(controllerA);
      scene.add(controllerB);

      assignControllerRoles();
    }

    function setupController(controller){
      if (!controller) return;

      controller.userData.isSelecting = false;
      controller.userData.isSqueezing = false;
      controller.userData.handedness = controller.userData.handedness || "unknown";

      controller.addEventListener("selectstart", ()=>{ controller.userData.isSelecting = true; });
      controller.addEventListener("selectend", ()=>{ controller.userData.isSelecting = false; onRelease(); });

      controller.addEventListener("squeezestart", ()=>{
        controller.userData.isSqueezing = true;

        // Menu toggle only on MENU HAND (wrist hand)
        if (controller === menuController) {
          setMenuVisible(!uiState.menuVisible);
          return;
        }

        // Grab only on POINTER HAND (right) when FLOAT mode
        if (controller === pointerController) {
          if (tryStartGrab(controller)) {
            hapticPulse(controller, 0.18, 18);
          }
        }
      });

      controller.addEventListener("squeezeend", ()=>{
        controller.userData.isSqueezing = false;
        if (controller === pointerController && grabState.active) {
          stopGrab(true);
          hapticPulse(controller, 0.12, 16);
        }
      });

      controller.addEventListener("connected", (event)=>{
        if (event?.data?.handedness) controller.userData.handedness = event.data.handedness;
        assignControllerRoles();
      });

      controller.addEventListener("disconnected", ()=>{
        controller.userData.handedness = "unknown";
        assignControllerRoles();
      });

      // Pointer line (right hand)
      const pointerGeo = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1) ]);
      const pointerMat = new THREE.LineBasicMaterial({ color: 0x00f2ff });
      const pointer = new THREE.Line(pointerGeo, pointerMat);
      pointer.scale.z = 6;
      pointer.visible = false;
      controller.add(pointer);
      controller.userData.pointerLine = pointer;
    }

    function assignControllerRoles(){
      const controllers = [controllerA, controllerB].filter(Boolean);

      const right = controllers.find(c=>c.userData.handedness === "right") || controllerA || controllers[0] || null;
      const left  = controllers.find(c=>c.userData.handedness === "left")  || controllerB || controllers[1] || controllers[0] || null;

      let desiredMenu = left;
      let desiredPointer = right;
      if (forceSwapHands) { const tmp = desiredMenu; desiredMenu = desiredPointer; desiredPointer = tmp; }

      menuController = desiredMenu;
      pointerController = desiredPointer;

      controllers.forEach(c=>{
        if (c.userData.pointerLine) c.userData.pointerLine.visible = (c === pointerController);
      });

      // Apply UI mode attachment based on current menu hand
      applyUIModeAndAttach();
    }

    function toggleMenuHand(){
      forceSwapHands = !forceSwapHands;
      assignControllerRoles();
      hapticPulse(menuController, 0.25, 18);
      uiDirtyHud = true; uiDirtyMenu = true;
      scheduleSave();
    }

    function hapticPulse(controller, strength=0.2, duration=20){
      try{
        const gp = controller?.gamepad;
        const h = gp?.hapticActuators?.[0];
        if (h?.pulse) h.pulse(strength, duration);
      }catch{}
    }

    // ===================== VR SESSION =====================
    function onEnterVR(){
      inVR = true;
      controls.enabled = false;

      document.getElementById("ui-layer").style.display = "none";
      document.getElementById("perf-pill").textContent = "VR";

      try { renderer.xr.setFoveation(config.xrFoveation); } catch {}
      try { renderer.xr.setFramebufferScaleFactor(config.xrScaleFactor); } catch {}

      recenterScreenRig(config.vrScreenDistance);
      updateScreenGeometryLOD();
      setMenuVisible(false);

      applyUIModeAndAttach();
      updateUIModePill();
    }

    function onExitVR(){
      inVR = false;
      controls.enabled = true;

      document.getElementById("ui-layer").style.display = "";
      document.getElementById("perf-pill").textContent = "Desktop";

      try { renderer.xr.setFramebufferScaleFactor(1.0); } catch {}

      screenRig.position.set(0,0,0);
      screenRig.rotation.set(0,0,0);

      camera.position.set(0,0,config.baseDistanceDesktop);
      controls.target.set(0,0,0);
      controls.update();

      setMenuVisible(false);

      if (grabState.active) stopGrab(true);
    }

    function recenterScreenRig(distance=3.0){
      const xrCam = renderer.xr.getCamera(camera);
      const cam = (xrCam && xrCam.isArrayCamera && xrCam.cameras?.length) ? xrCam.cameras[0] : camera;

      const camPos = new THREE.Vector3();
      const camQuat = new THREE.Quaternion();
      cam.getWorldPosition(camPos);
      cam.getWorldQuaternion(camQuat);

      const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camQuat).normalize();
      const target = camPos.clone().add(forward.multiplyScalar(distance));

      screenRig.position.copy(target);
      screenRig.lookAt(camPos);
      screenRig.rotation.x = 0;
      screenRig.rotation.z = 0;
    }

    // ===================== LOOP =====================
    function animate(nowMs){
      const dt = Math.max(1, nowMs - uiState._lastFrameMs);
      uiState._lastFrameMs = nowMs;
      const fps = 1000 / dt;
      uiState._fpsSmoothed = uiState._fpsSmoothed ? (uiState._fpsSmoothed*0.9 + fps*0.1) : fps;

      updateXRCameraRefs();
      updateDesktopTimeUI(nowMs);
      updateReactiveBackground(nowMs);

      // Host periodic sync
      if (peer && roomCode && isHost && !videoElement.paused) {
        if (nowMs - lastHostSyncMs > config.netSyncIntervalMs) {
          lastHostSyncMs = nowMs;
          emitNetAction("sync");
        }
      }

      // Update float grab
      updateGrab();

      // VR pointer interactions
      if (pointerController) updatePointerInteraction(pointerController);

      const labelTick = (nowMs - uiState._lastLabelTick) > 150;
      if (labelTick){
        uiState._lastLabelTick = nowMs;
        uiDirtyHud = true;
        if (uiState.menuVisible) uiDirtyMenu = true;
      }
      if (uiState.dragging) uiDirtyMenu = true;

      drawHUD({ force:false });
      drawMenu({ force:false });

      renderer.render(scene, camera);
    }

    // ===================== INTERACTION =====================
    function updatePointerInteraction(controller){
      // If grabbing, don't also click UI
      if (grabState.active) return;

      tempMatrix.identity().extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0,0,-1).applyMatrix4(tempMatrix);

      const targets = uiState.menuVisible ? [hudMesh, menuMesh] : [hudMesh];
      const hits = raycaster.intersectObjects(targets, false);

      if (!hits.length){
        if (!uiState.dragging) setHover(null);
        return;
      }

      const hit = hits[0];
      const uv = hit.uv;
      if (!uv) return;

      const selecting = controller.userData.isSelecting;

      if (hit.object === hudMesh){
        const cx = uv.x * hudCanvas.width;
        const cy = (1 - uv.y) * hudCanvas.height;
        updateHUDInteraction(cx, cy, selecting);
        return;
      }

      if (hit.object === menuMesh && uiState.menuVisible){
        const cx = uv.x * menuCanvas.width;
        const cy = (1 - uv.y) * menuCanvas.height;
        updateMenuInteraction(cx, cy, selecting);
        return;
      }
    }

    function setHover(id){
      if (uiState.hoverId !== id){
        uiState.hoverId = id;
        uiDirtyHud = true;
        uiDirtyMenu = true;
      }
    }

    function findHudTarget(cx, cy){
      for (const r of uiState._hudRects){
        if (cx >= r.x && cx <= r.x+r.w && cy >= r.y && cy <= r.y+r.h) return r;
      }
      return null;
    }

    function updateHUDInteraction(cx, cy, selecting){
      if (uiState.dragging) return;

      const target = findHudTarget(cx, cy);
      setHover(target ? target.id : null);

      if (selecting && target && uiState.activeId !== target.id){
        uiState.activeId = target.id;
        handleHudPress(target.id);
        hapticPulse(pointerController, 0.18, 16);
        uiDirtyHud = true; uiDirtyMenu = true;
      }

      if (!selecting && uiState.activeId && uiState.activeId.startsWith("hud:")){
        uiState.activeId = null;
      }
    }

    function handleHudPress(id){
      switch(id){
        case "hud:menu": setMenuVisible(!uiState.menuVisible); break;
        case "hud:back": seekBy(-10); break;
        case "hud:fwd":  seekBy(10); break;
        case "hud:play": togglePlay(); break;
        case "hud:mode":
          setStereo(state.stereoMode === "mono" ? "sbs" : (state.stereoMode === "sbs" ? "ou" : "mono"));
          break;
      }
    }

    function findMenuTarget(cx, cy){
      for (const r of uiRects){
        if (r.type === "buttonRow"){
          for (const b of r.buttons){
            if (cx >= b.x && cx <= b.x+b.w && cy >= b.y && cy <= b.y+b.h) return { type:"button", button:b };
          }
        }
      }
      for (const r of uiRects){
        if (cx >= r.x && cx <= r.x+r.w && cy >= r.y && cy <= r.y+r.h) return { type:"rect", rect:r };
      }
      return null;
    }

    function updateMenuInteraction(cx, cy, selecting){
      if (uiState.dragging && uiState.activeId){
        applyDrag(cx);
        return;
      }

      const hit = findMenuTarget(cx, cy);
      if (!hit){ setHover(null); return; }

      if (hit.type === "button"){
        setHover(hit.button.id);
        if (selecting && uiState.activeId !== hit.button.id){
          uiState.activeId = hit.button.id;
          hit.button.onPress?.();
          uiDirtyMenu = true; uiDirtyHud = true;
          scheduleSave(true);
          hapticPulse(pointerController, 0.22, 18);
        }
        if (!selecting && uiState.activeId === hit.button.id) uiState.activeId = null;
        return;
      }

      const r = hit.rect;
      setHover(r.id);

      if (selecting){
        if (!uiState.activeId){
          uiState.activeId = r.id;

          if (r.type === "slider"){
            uiState.dragging = true;
            applySliderAt(r, cx);
            hapticPulse(pointerController, 0.10, 12);
            return;
          }
          if (r.type === "seek"){
            uiState.dragging = true;
            applySeekAt(r, cx);
            hapticPulse(pointerController, 0.10, 12);
            return;
          }
          if (r.type === "toggle"){
            state[r.item.param] = !state[r.item.param];
            applyStateToScene(false);
            uiDirtyMenu = true; uiDirtyHud = true;
            scheduleSave(true);
            syncDesktopFromState();
            hapticPulse(pointerController, 0.20, 16);
            return;
          }
        }
      } else {
        if (uiState.activeId === r.id) uiState.activeId = null;
      }
    }

    function onRelease(){
      if (uiState.dragging){
        uiState.dragging = false;
        uiState.activeId = null;
        scheduleSave(true);
        syncDesktopFromState();
      } else {
        uiState.activeId = null;
      }
    }

    function applyDrag(cx){
      const active = uiState.activeId;
      if (!active) return;
      const r = uiRects.find(rr => rr.id === active);
      if (r?.type === "slider") applySliderAt(r, cx);
      if (r?.type === "seek") applySeekAt(r, cx);
    }

    function applySliderAt(r, cx){
      const u = (cx - r.track.x) / r.track.w;
      const t = clamp01(u);
      const raw = r.item.min + t * (r.item.max - r.item.min);
      const stepped = r.item.step ? (Math.round(raw / r.item.step) * r.item.step) : raw;

      const prev = state[r.item.param];
      if (Math.abs(prev - stepped) > 1e-6){
        state[r.item.param] = stepped;

        // Wrist sliders: apply to wrist only if in wrist mode; if float mode, they still adjust wrist offsets (for later attach)
        if (r.item.param.startsWith("uiHand")) {
          if (state.uiMode === "wrist") applyUIModeAndAttach();
        }

        applyStateToScene(false);
        uiDirtyMenu = true; uiDirtyHud = true;
      }
    }

    function applySeekAt(r, cx){
      const dur = videoElement.duration;
      if (!isFinite(dur) || dur <= 0) return;

      const u = (cx - r.track.x) / r.track.w;
      const t = clamp01(u);
      const newTime = t * dur;

      if (Math.abs(videoElement.currentTime - newTime) > 0.03){
        videoElement.currentTime = newTime;
        uiDirtyMenu = true; uiDirtyHud = true;
      }
    }

    function setMenuVisible(visible){
      uiState.menuVisible = !!visible;
      menuMesh.visible = uiState.menuVisible;
      uiDirtyMenu = true;
      uiDirtyHud = true;
      hapticPulse(menuController, 0.15, 20);
    }

    // ===================== APPLY STATE =====================
    function applyStateToScene(initial=false){
      updateScreenGeometryLOD();

      videoMesh.scale.set(state.mScale, state.mScale, 1);

      fxMesh.scale.set(
        state.mScale * 1.8 * state.fxScaleW,
        state.mScale * 1.8 * state.fxScaleH,
        1
      );

      videoMesh.position.y = state.mY;
      fxMesh.position.y = state.mY;

      videoMesh.position.z = state.mDepth;
      fxMesh.position.z = state.mDepth - 1.5;

      // Screen uniforms
      videoMaterial.uniforms.uCurve.value = state.mCurve;
      videoMaterial.uniforms.uRadius.value = state.mRadius;
      videoMaterial.uniforms.uSoftness.value = state.mSoftness;

      // Stereo/parallax (shared)
      const modeInt = state.stereoMode === "sbs" ? 1 : (state.stereoMode === "ou" ? 2 : 0);
      const swapInt = state.swapEyes ? 1 : 0;

      videoMaterial.uniforms.uStereoMode.value = modeInt;
      videoMaterial.uniforms.uSwapEyes.value = swapInt;
      videoMaterial.uniforms.uParallax.value = state.mParallax;

      fxMaterial.uniforms.uStereoMode.value = modeInt;
      fxMaterial.uniforms.uSwapEyes.value = swapInt;
      fxMaterial.uniforms.uParallax.value = state.mParallax;

      fxMaterial.uniforms.uCurve.value = state.mCurve;
      fxMaterial.uniforms.uBlurAmount.value = state.fxBlur;
      fxMaterial.uniforms.uIntensity.value = state.fxIntensity;
      fxMaterial.uniforms.uFxRadius.value = state.fxRadius;
      fxMaterial.uniforms.uFxSoftness.value = state.fxSoftness;

      fxMesh.visible = !!state.fxEnabled;

      videoElement.volume = clamp01(state.volume);

      envGroup.position.set(state.envPosX, state.envPosY, state.envPosZ);
      envGroup.rotation.set(
        THREE.MathUtils.degToRad(state.envRotX),
        THREE.MathUtils.degToRad(state.envRotY),
        THREE.MathUtils.degToRad(state.envRotZ)
      );
      envGroup.scale.setScalar(state.envSphere);
      if (envStarsMat) envStarsMat.opacity = clamp01(state.envStars);

      if (!initial){
        uiDirtyMenu = true;
        uiDirtyHud = true;
      }
    }

    function isButtonActive(b){
      if (b.baseId === "modes"){
        return (b.btnId === "mono" && state.stereoMode === "mono")
          || (b.btnId === "sbs" && state.stereoMode === "sbs")
          || (b.btnId === "ou"  && state.stereoMode === "ou");
      }
      if (b.baseId === "uimode"){
        if (b.btnId === "float") return state.uiMode === "float";
        if (b.btnId === "attach") return state.uiMode === "wrist";
      }
      return false;
    }

    function buttonLabelFor(b){ return b.label; }

    // ===================== DESKTOP UI =====================
    function setupDesktopUI(){
      document.getElementById("btn-play").addEventListener("click", ()=>togglePlay());
      document.getElementById("btn-back").addEventListener("click", ()=>seekBy(-10));
      document.getElementById("btn-fwd").addEventListener("click", ()=>seekBy(10));
      document.getElementById("btn-recenter").addEventListener("click", ()=>recenterScreenRig(config.baseDistanceDesktop));

      document.getElementById("btn-clear-settings").addEventListener("click", ()=>{
        try{ localStorage.removeItem(STORE_KEY); }catch{}
        deleteCookie(COOKIE_KEY);
      });

      // PeerJS
      document.getElementById("btn-host-room").addEventListener("click", ()=>hostRoom(document.getElementById("input-room").value));
      document.getElementById("btn-join-room").addEventListener("click", ()=>joinRoom(document.getElementById("input-room").value));
      document.getElementById("btn-leave-room").addEventListener("click", ()=>disconnectRoom());

      // Host URL load
      document.getElementById("btn-load-url").addEventListener("click", ()=>{
        const url = (document.getElementById("input-video-url").value || "").trim();
        if (!url) return;

        if (peer && roomCode && !isHost) {
          loadVideoURL(url, { userInitiated:false, suppressNet:true });
          updateNetUI("Guest loaded URL locally (host-only broadcast)");
          return;
        }
        loadVideoURL(url, { userInitiated:true });
      });

      // Wrist UI buttons
      document.getElementById("btn-ui-float").addEventListener("click", ()=>{ setUIMode("float"); scheduleSave(true); updateUIModePill(); });
      document.getElementById("btn-ui-attach").addEventListener("click", ()=>{ setUIMode("wrist"); scheduleSave(true); updateUIModePill(); });
      document.getElementById("btn-ui-reset").addEventListener("click", ()=>{ resetWristOffsets(); scheduleSave(true); updateUIModePill(); });

      // Seek bar
      let scrubbing = false;
      const seek = document.getElementById("input-seek");
      seek.addEventListener("pointerdown", ()=>scrubbing=true);
      seek.addEventListener("pointerup", ()=>scrubbing=false);
      seek.addEventListener("input", (e)=>{
        if (!isFinite(videoElement.duration) || videoElement.duration <= 0) return;
        const t = parseFloat(e.target.value) * videoElement.duration;
        if (scrubbing && isFinite(t)) videoElement.currentTime = t;
      });

      // Basic
      document.getElementById("input-stereo-mode").addEventListener("change", (e)=>{
        state.stereoMode = e.target.value;
        applyStateToScene(false);
        scheduleSave();
      });

      document.getElementById("input-swap-eyes").addEventListener("change", (e)=>{
        state.swapEyes = !!e.target.checked;
        applyStateToScene(false);
        scheduleSave();
      });

      document.getElementById("input-fx-enabled").addEventListener("change", (e)=>{
        state.fxEnabled = !!e.target.checked;
        applyStateToScene(false);
        scheduleSave();
      });

      document.getElementById("input-bg-reactive").addEventListener("change", (e)=>{
        state.bgReactive = !!e.target.checked;
        scheduleSave();
      });

      document.getElementById("input-volume").addEventListener("input", (e)=>{
        state.volume = parseFloat(e.target.value);
        applyStateToScene(false);
        scheduleSave();
      });

      // Screen
      wireSlider("input-scale",    (v)=>{ state.mScale = v; applyStateToScene(false); scheduleSave(); });
      wireSlider("input-y",        (v)=>{ state.mY = v; applyStateToScene(false); scheduleSave(); });
      wireSlider("input-depth",    (v)=>{ state.mDepth = v; applyStateToScene(false); scheduleSave(); });
      wireSlider("input-curve",    (v)=>{ state.mCurve = v; applyStateToScene(false); scheduleSave(); });
      wireSlider("input-radius",   (v)=>{ state.mRadius = v; applyStateToScene(false); scheduleSave(); });
      wireSlider("input-softness", (v)=>{ state.mSoftness = v; applyStateToScene(false); scheduleSave(); });
      wireSlider("input-parallax", (v)=>{ state.mParallax = v; applyStateToScene(false); scheduleSave(); });

      // Effects
      wireSlider("input-fx-w",        (v)=>{ state.fxScaleW = v; applyStateToScene(false); scheduleSave(); });
      wireSlider("input-fx-h",        (v)=>{ state.fxScaleH = v; applyStateToScene(false); scheduleSave(); });
      wireSlider("input-fx-radius",   (v)=>{ state.fxRadius = v; applyStateToScene(false); scheduleSave(); });
      wireSlider("input-fx-softness", (v)=>{ state.fxSoftness = v; applyStateToScene(false); scheduleSave(); });
      wireSlider("input-fx-intensity",(v)=>{ state.fxIntensity = v; applyStateToScene(false); scheduleSave(); });
      wireSlider("input-fx-blur",     (v)=>{ state.fxBlur = v; applyStateToScene(false); scheduleSave(); });

      // Env
      wireSlider("input-env-rotx",(v)=>{ state.envRotX = v; applyStateToScene(false); scheduleSave(); });
      wireSlider("input-env-roty",(v)=>{ state.envRotY = v; applyStateToScene(false); scheduleSave(); });
      wireSlider("input-env-rotz",(v)=>{ state.envRotZ = v; applyStateToScene(false); scheduleSave(); });
      wireSlider("input-env-sphere",(v)=>{ state.envSphere = v; applyStateToScene(false); scheduleSave(); });
      wireSlider("input-env-stars",(v)=>{ state.envStars = v; applyStateToScene(false); scheduleSave(); });
      wireSlider("input-env-x",(v)=>{ state.envPosX = v; applyStateToScene(false); scheduleSave(); });
      wireSlider("input-env-y",(v)=>{ state.envPosY = v; applyStateToScene(false); scheduleSave(); });
      wireSlider("input-env-z",(v)=>{ state.envPosZ = v; applyStateToScene(false); scheduleSave(); });

      // Reactive BG
      wireSlider("input-bg-strength",(v)=>{ state.bgStrength = v; scheduleSave(); });
      wireSlider("input-bg-speed",(v)=>{ state.bgSpeed = v; scheduleSave(); });

      // Wrist offsets (wrist mode)
      wireSlider("input-ui-posx",(v)=>{ state.uiHandPosX = v; if (state.uiMode==="wrist") applyUIModeAndAttach(); scheduleSave(); });
      wireSlider("input-ui-posy",(v)=>{ state.uiHandPosY = v; if (state.uiMode==="wrist") applyUIModeAndAttach(); scheduleSave(); });
      wireSlider("input-ui-posz",(v)=>{ state.uiHandPosZ = v; if (state.uiMode==="wrist") applyUIModeAndAttach(); scheduleSave(); });
      wireSlider("input-ui-rotx",(v)=>{ state.uiHandRotX = v; if (state.uiMode==="wrist") applyUIModeAndAttach(); scheduleSave(); });
      wireSlider("input-ui-roty",(v)=>{ state.uiHandRotY = v; if (state.uiMode==="wrist") applyUIModeAndAttach(); scheduleSave(); });
      wireSlider("input-ui-rotz",(v)=>{ state.uiHandRotZ = v; if (state.uiMode==="wrist") applyUIModeAndAttach(); scheduleSave(); });

      // File load/reset
      const fileInput = document.getElementById("input-file");
      fileInput.addEventListener("change", (e)=>{
        const file = e.target.files?.[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        loadVideoURL(url, { userInitiated:true }); // blob won't broadcast
      });

      document.getElementById("btn-reset-video").addEventListener("click", ()=>{
        const defaultSrc = document.getElementById("video-default-src")?.getAttribute("src");
        if (defaultSrc) loadVideoURL(defaultSrc, { userInitiated:true });
        document.getElementById("input-file").value = "";
      });

      window.addEventListener("dragover", (e)=>e.preventDefault());
      window.addEventListener("drop", (e)=>{
        e.preventDefault();
        const file = e.dataTransfer?.files?.[0];
        if (!file || !file.type.startsWith("video/")) return;
        const url = URL.createObjectURL(file);
        loadVideoURL(url, { userInitiated:true });
        document.getElementById("input-file").value = "";
      });
    }

    function wireSlider(id, onChange){
      const el = document.getElementById(id);
      el.addEventListener("input", (e)=>onChange(parseFloat(e.target.value)));
    }

    function syncDesktopFromState(){
      document.getElementById("input-stereo-mode").value = state.stereoMode;
      document.getElementById("input-swap-eyes").checked = state.swapEyes;
      document.getElementById("input-fx-enabled").checked = state.fxEnabled;
      document.getElementById("input-bg-reactive").checked = state.bgReactive;

      document.getElementById("input-scale").value = state.mScale;
      document.getElementById("input-y").value = state.mY;
      document.getElementById("input-depth").value = state.mDepth;
      document.getElementById("input-curve").value = state.mCurve;
      document.getElementById("input-radius").value = state.mRadius;
      document.getElementById("input-softness").value = state.mSoftness;
      document.getElementById("input-parallax").value = state.mParallax;

      document.getElementById("input-fx-w").value = state.fxScaleW;
      document.getElementById("input-fx-h").value = state.fxScaleH;
      document.getElementById("input-fx-radius").value = state.fxRadius;
      document.getElementById("input-fx-softness").value = state.fxSoftness;
      document.getElementById("input-fx-intensity").value = state.fxIntensity;
      document.getElementById("input-fx-blur").value = state.fxBlur;

      document.getElementById("input-env-rotx").value = state.envRotX;
      document.getElementById("input-env-roty").value = state.envRotY;
      document.getElementById("input-env-rotz").value = state.envRotZ;
      document.getElementById("input-env-sphere").value = state.envSphere;
      document.getElementById("input-env-stars").value = state.envStars;
      document.getElementById("input-env-x").value = state.envPosX;
      document.getElementById("input-env-y").value = state.envPosY;
      document.getElementById("input-env-z").value = state.envPosZ;

      document.getElementById("input-bg-strength").value = state.bgStrength;
      document.getElementById("input-bg-speed").value = state.bgSpeed;

      document.getElementById("input-ui-posx").value = state.uiHandPosX;
      document.getElementById("input-ui-posy").value = state.uiHandPosY;
      document.getElementById("input-ui-posz").value = state.uiHandPosZ;
      document.getElementById("input-ui-rotx").value = state.uiHandRotX;
      document.getElementById("input-ui-roty").value = state.uiHandRotY;
      document.getElementById("input-ui-rotz").value = state.uiHandRotZ;

      document.getElementById("input-volume").value = state.volume;

      updateUIModePill();
      updatePlayUI();
    }

    // ===================== VIDEO CONTROL =====================
    function togglePlay(){
      if (videoElement.paused) videoElement.play().catch(()=>{});
      else videoElement.pause();
    }

    function seekBy(sec){
      const dur = videoElement.duration;
      if (!isFinite(dur) || dur <= 0) return;
      videoElement.currentTime = THREE.MathUtils.clamp(videoElement.currentTime + sec, 0, dur);
      uiDirtyHud = true; uiDirtyMenu = true;
    }

    function updateCurrentVideoURLLabel(){
      const url = currentShareableURL();
      const el = document.getElementById("current-video-url");
      el.textContent = url ? url : "(local or default)";
    }

    function loadVideoURL(url, opts={}){
      const time = (typeof opts.time === "number") ? opts.time : null;
      const paused = (typeof opts.paused === "boolean") ? opts.paused : null;
      const suppressNet = !!opts.suppressNet;
      const userInitiated = !!opts.userInitiated;

      suppressNetwork = true;

      videoElement.pause();
      videoElement.src = url;
      videoElement.load();

      const applyAfterMeta = () => {
        if (time !== null && isFinite(time)){
          try{ videoElement.currentTime = Math.min(time, isFinite(videoElement.duration) ? videoElement.duration : time); }catch{}
        }
        if (paused === true) videoElement.pause();
        else if (paused === false) videoElement.play().catch(()=>{});
        else videoElement.play().catch(()=>{});

        suppressNetwork = false;

        uiDirtyHud = true; uiDirtyMenu = true;
        updatePlayUI();
        updateCurrentVideoURLLabel();

        if (!suppressNet && userInitiated) emitNetLoad();
      };

      videoElement.addEventListener("loadedmetadata", applyAfterMeta, { once:true });

      if (bgAnalyzerBroken){
        bgAnalyzerBroken = false;
        state.bgReactive = true;
        syncDesktopFromState();
        scheduleSave();
      }
    }

    function updatePlayUI(){
      document.getElementById("btn-play").textContent = videoElement.paused ? "Play" : "Pause";
      state.paused = videoElement.paused;
    }

    function setStereo(mode){
      state.stereoMode = mode;
      applyStateToScene(false);
      syncDesktopFromState();
      uiDirtyMenu = true; uiDirtyHud = true;
      scheduleSave();
    }

    function updateDesktopTimeUI(nowMs){
      if (!updateDesktopTimeUI._t) updateDesktopTimeUI._t = 0;
      if (nowMs - updateDesktopTimeUI._t < 200) return;
      updateDesktopTimeUI._t = nowMs;

      const dur = videoElement.duration;
      const cur = videoElement.currentTime;

      document.getElementById("time-readout").textContent = `${fmtTime(cur)} / ${fmtTime(dur)}`;
      if (isFinite(dur) && dur > 0){
        document.getElementById("input-seek").value = clamp01(cur/dur);
      }
    }

    // ===================== RESIZE =====================
    function onWindowResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ===================== HELPERS =====================
    function clamp01(v){ return Math.max(0, Math.min(1, v)); }
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    function fmtTime(s){
      if (!isFinite(s) || s < 0) return "00:00";
      const m = Math.floor(s/60);
      const ss = Math.floor(s%60);
      return `${String(m).padStart(2,"0")}:${String(ss).padStart(2,"0")}`;
    }

    function roundRect(ctx, x, y, w, h, r){
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath();
    }

    // ===================== NET PILL =====================
    setInterval(()=>{
      const pill = document.getElementById("net-pill");
      if (!peer) { pill.textContent = "Offline"; return; }
      if (roomCode) {
        if (isHost) pill.textContent = `Host • ${roomCode} • ${conns.size} guest(s)`;
        else pill.textContent = (mainConn && mainConn.open) ? `Guest • ${roomCode}` : `Guest • ${roomCode} (connecting)`;
      } else {
        pill.textContent = "Online";
      }
    }, 800);
  </script>
</body>
</html>
